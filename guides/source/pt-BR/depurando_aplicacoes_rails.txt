Depurando Aplicações Rails
============================

Este guia apresenta técnicas para depurar aplicações no Ruby on Rails. Através deste guia, você será capaz de:

* Compreender o próposito de uma depuração
* Pesquisar problemas e questões em sua aplicação que não estão sendo identificados pelos seus testes
* Aprender os diferentes métodos de depuração
* Analizar a pilha de execução

== View Helpers para Depuração

Uma tarefa comum é inspecionar os conteúdos de uma variável. No Rails, você pode fazer isto de três formas:

* `debug`
* `to_yaml`
* `inspect`

=== debug

O helper `debug` retornará uma tag <pre> que renderiza o objeto utilizando o formato YAML. Isto gera um bloco de dados legível para um humano a partir de qualquer objeto. Por exemplo, se você tiver este código em uma view:

[source, html]
----------------------------------------------------------------------------
<%= debug @post %>
<p>
  <b>Título:</b>
  <%=h @post.title %>
</p>
----------------------------------------------------------------------------

Você verá algo parecido com isto:

----------------------------------------------------------------------------
--- !ruby/object:Post
attributes:
  updated_at: 2008-09-05 22:55:47
  body: É um guia muito útil para depurar suas aplicações Rails.
  title: Guia de depuração com Rails
  published: t
  id: "1"
  created_at: 2008-09-05 22:55:47
attributes_cache: {}


Title: Guia de depuração com Rails
----------------------------------------------------------------------------

=== to_yaml

Para imprimir no formato YAML uma variável de instância ou qualquer outro objeto ou método, você pode fazer da seguinte forma:

[source, html]
----------------------------------------------------------------------------
<%= simple_format @post.to_yaml %>
<p>
  <b>Título:</b>
  <%=h @post.title %>
</p>
----------------------------------------------------------------------------

O método `to_yaml` converte o método para o formato YAML, deixando-o mais legível, e então o helper `simple_format` é utilizado para renderizar cada linha como acontece em um console. Esta é a forma pela qual o método `debug` realiza a sua mágica.

Como resultado, você terá o seguinte em sua view:

----------------------------------------------------------------------------
--- !ruby/object:Post
attributes:
updated_at: 2008-09-05 22:55:47
body: É um guia muito útil para depurar suas aplicações Rails.
title: Guia de depuração com Rails
published: t
id: "1"
created_at: 2008-09-05 22:55:47
attributes_cache: {}

Title: Guia de depuração com Rails
----------------------------------------------------------------------------

=== inspect

Outro método útil para imprimir valores de objetos é o `inspect`, especialmente quando se está trabalhando com arrays ou hashes.  Ele imprimirá o valor do objeto como uma string. Por exemplo:

[source, html]
----------------------------------------------------------------------------
<%= [1, 2, 3, 4, 5].inspect %>
<p>
  <b>Título:</b>
  <%=h @post.title %>
</p>
----------------------------------------------------------------------------

Será renderizado da seguinte forma:

----------------------------------------------------------------------------
[1, 2, 3, 4, 5]

Title: Guia de depuração com Rails
----------------------------------------------------------------------------

=== Depurando Javascript

Rails possui suporte embutido para se depurar RJS. Para ativá-lo, ajuste `ActionView::Base.debug_rjs` para _true_. Isto especificará que respostas RJS serão encapsuladas em um bloco try/catch que realizará alert()s quando uma exceção for capturada (a exceção então é relançada).

Para habilitá-lo, adicione a seguinte linha ao bloco `Rails::Initializer do |config|` dentro de +environment.rb+:

[source, ruby]
----------------------------------------------------------------------------
config.action_view[:debug_rjs] = true
----------------------------------------------------------------------------

Ou, a qualquer momento, ajuste `ActionView::Base.debug_rjs` para _true_:

[source, ruby]
----------------------------------------------------------------------------
ActionView::Base.debug_rjs = true
----------------------------------------------------------------------------

[TIP]
Para mais informações ao depurar javascript visite a página do link:http://getfirebug.com/[Firebug], a popular extensão de depuração para o Firefox.

== O Logger

Também pode ser útil guardar informações em arquivos de log durante a execução de sua aplicação. O Rails mantém um arquivo de log separado para cada ambiente de execução.

=== O que é O Logger?

Rails utiliza o `logger` padrão do Ruby para escrever informações de log. Você pode substituí-lo por outros loggers, como o `Log4R` se você preferir.

Você pode especificar um logger alternativo em seu +environment.rb+ ou em qualquer arquivo de ambiente:

[source, ruby]
----------------------------------------------------------------------------
ActiveRecord::Base.logger = Logger.new(STDOUT)
ActiveRecord::Base.logger = Log4r::Logger.new("Log da Aplicação")
----------------------------------------------------------------------------

Ou, na seção +Initializer+, adicione _algum_ dos seguintes

[source, ruby]
----------------------------------------------------------------------------
config.logger = Logger.new(STDOUT)
config.logger = Log4r::Logger.new("Log da Aplicação")
----------------------------------------------------------------------------

[TIP]
Por padrão, cada log é criado em `RAILS_ROOT/log/` e o nome do arquivo de log é +environment_name.log+.

=== Níveis de Log

Quando uma mensagem é enviada para o log, ela é impressa no arquivo de log correspondente se o nível de log da mensagem é igual ou maior do que o nível configurado para o log. Para saber o nível configurado atual de um log, você pode chamar o método `ActiveRecord::Base.logger.level`.

Os níveis de log disponíveis são: +:debug+, +:info+, +:warn+, +:error+, e +:fatal+, correspondendo aos níveis de log dos número de 0 até 4 respectivamente. Para alterar o nível de log, utilize

[source, ruby]
----------------------------------------------------------------------------
config.log_level = Logger::WARN # Em qualquer inicializador de ambiente, ou
ActiveRecord::Base.logger.level = 0 # a qualquer momento
----------------------------------------------------------------------------

Isto é útil para quando você deseja depurar algo durante o desenvolvimento e estagiamento, mas não deseja encher seu log de produção com informações desnecessárias.

[TIP]
O nível de log padrão do Rails é +info+ no modo de produção e +debug+ nos modos de desenvolvimento e teste.

=== Enviando Mensagens

Para escrever no log atual, utilize o método `logger.(debug|info|warn|error|fatal)` dentro de um controller, model ou mailer:

[source, ruby]
----------------------------------------------------------------------------
logger.debug "Hash de atributos de uma pessoa: #{@person.attributes.inspect}"
logger.info "Processando requisição..."
logger.fatal "Finalizando aplicação, encontrado erro irrecuperável!!!"
----------------------------------------------------------------------------

Aqui temos um exemplo de um método utilizando opções de log:

[source, ruby]
----------------------------------------------------------------------------
class PostsController < ApplicationController
  # ...

  def create
    @post = Post.new(params[:post])
    logger.debug "Novo post: #{@post.attributes.inspect}"
    logger.debug "Post deve ser válido: #{@post.valid?}"

    if @post.save
      flash[:notice] = 'Post criado com sucesso.'
      logger.debug "O post foi salvo e agora o usuário será redirecionado..."
      redirect_to(@post)
    else
      render :action => "new"
    end
  end

  # ...
end
----------------------------------------------------------------------------

Aqui temos um exemplo do log gerado por este método:

----------------------------------------------------------------------------
Processing PostsController#create (for 127.0.0.1 at 2008-09-08 11:52:54) [POST]
  Session ID: BAh7BzoMY3NyZl9pZCIlMDY5MWU1M2I1ZDRjODBlMzkyMWI1OTg2NWQyNzViZjYiCmZsYXNoSUM6J0FjdGl
vbkNvbnRyb2xsZXI6OkZsYXNoOjpGbGFzaEhhc2h7AAY6CkB1c2VkewA=--b18cd92fba90eacf8137e5f6b3b06c4d724596a4
  Parameters: {"commit"=>"Create", "post"=>{"title"=>"Depurando Rails", 
 "body"=>"Estou aprendendo a imprimir em logs!!!", "published"=>"0"}, 
 "authenticity_token"=>"2059c1286e93402e389127b1153204e0d1e275dd", "action"=>"create", "controller"=>"posts"}
Novo post: {"updated_at"=>nil, "title"=>"Depurando Rails", "body"=>"Estou aprendendo a imprimir em logs!!!", 
 "published"=>false, "created_at"=>nil}
Post deve ser válido: true
  Post Create (0.000443)   INSERT INTO "posts" ("updated_at", "title", "body", "published", 
 "created_at") VALUES('2008-09-08 14:52:54', 'Depurando Rails', 
 'Estou aprendendo a imprimir em logs!!!', 'f', '2008-09-08 14:52:54')
O post foi salvo e agora o usuário será redirecionado...
Redirected to #<Post:0x20af760>
Completed in 0.01224 (81 reqs/sec) | DB: 0.00044 (3%) | 302 Found [http://localhost/posts]
----------------------------------------------------------------------------

Adicionar informações de logs extras como estas torna mais simples a busca por comportamentos inexperados ou incomuns em seus logs. Se você adicionar informações extras de log, certifique-se de utilizar corretamente os níveis de log, para evitar encher seu log de produção com informações não-úteis.

== Depurando com ruby-debug

Quando o seu código estiver comportando-se de forma diferente do esperado, você pode tentar imprimir mensagem nos logs ou no console para diagnosticar o problema. Infelizmente, pode acontecer de haver situações em que este tipo de análise de erro não ser efetivo para encontrar a raiz de um problema. Quando você precisar analisar mais profundamente seu código durante sua execução, o depurador será seu melhor amigo.

O depurador também poderá lhe ajudar caso você deseje aprender sobre o código fonte do Rails e não souber por onde começar. Simplesmente depure qualquer requisição em sua aplicação e utilize este guia para aprender como se aprofundar a partir de seu código para o código do Rails.

=== Configuração

O depurador utilizado pelo Rails, +ruby-debug+, vem em forma de uma gem. Para instalá-lo, execute:

[source, shell]
----------------------------------------------------------------------------
$ sudo gem install ruby-debug
----------------------------------------------------------------------------

No caso do você precisar baixar uma versão diferente ou o código fonte, você pode acessar link:http://rubyforge.org/projects/ruby-debug/[a página do projeto no rubyforge].

O Rails tem suporte ao ruby-debug desde a versão 2.0. Dentro de qualquer aplicação Rails você pode utilizar o depurador chamando o método `debugger`.

Aqui temos um exemplo:

[source, ruby]
----------------------------------------------------------------------------
class PeopleController < ApplicationController
  def new
    debugger
    @person = Person.new
  end
end
----------------------------------------------------------------------------

Se você receber a seguinte mensagem no console ou nos logs:

----------------------------------------------------------------------------
***** Debugger requested, but was not available: Start server with --debugger to enable *****
----------------------------------------------------------------------------

Certifique-se de iniciar o seu servidor web com a opção +--debugger+:

[source, shell]
----------------------------------------------------------------------------
~/PathTo/rails_project$ script/server --debugger
=> Booting Mongrel (use 'script/server webrick' to force WEBrick)
=> Rails 2.2.0 application starting on http://0.0.0.0:3000
=> Debugger enabled
...
----------------------------------------------------------------------------

[TIP]
No modo de desenvolvimento, você pode dinamicamente utilizar o depurador com `require \'ruby-debug\'` ao invés de ter de reiniciar o servidor, se ele não foi iniciado com a opção `--debugger`.

Para utilizar o depurador do Rails você deverá utilizar o *WEBrick* ou o *Mongrel*. No momento, nenhum servidor alternativo possui suporte a depuração.

=== A Interface

Assim que sua aplicação invocar o método `debugger`, o depurador será inicializado em uma interface de depuração dentro do terminal de onde você iniciou seu servidor de aplicações, e você poderá interagir com o prompt do ruby-debug `(rdb:n)`. O _n_ é o número da thread. O prompt também lhe mostrará a próxima linha de código que está na espera para ser executada.

Se o código for chamado a partir de uma requisição de um navegador, a aba do navegador contendo a requisição será paralisada até que o processo de depuração e toda a requisição sejam finalizados.

Por exemplo:

----------------------------------------------------------------------------
@posts = Post.find(:all)
(rdb:7)
----------------------------------------------------------------------------

Agora é a hora de explorar a sua aplicação. Uma boa forma de começar é pedir ajuda ao depurador... então digite: `help` (você não esperava por esta, né?)

----------------------------------------------------------------------------
(rdb:7) help
ruby-debug help v0.10.2
Type 'help <command-name>' for help on a specific command

Available commands:
backtrace  delete   enable  help    next  quit     show    trace
break      disable  eval    info    p     reload   source  undisplay
catch      display  exit    irb     pp    restart  step    up
condition  down     finish  list    ps    save     thread  var
continue   edit     frame   method  putl  set      tmate   where
----------------------------------------------------------------------------

[TIP]
Para visualizar o menu de ajuda de qualquer comando utilize `help <command-name>` durante o modo de depuração. Por exemplo: _+help var+_

O próximo comando que veremos é um dos mais úteis: `list`. Você também pode abreviar comandos do ruby-debug digitando somente as letras necessárias para distingüir o comando de outros comandos. Desta forma você pode, por exemplo, utilizar o +l+ para o comando +list+.

Este comando mostra onde você está no código imprimindo 10 linhas ao redor da linha atual; neste exemplo, a linha atual é a 6 e está marcada com um +=>+.

----------------------------------------------------------------------------
(rdb:7) list
[1, 10] in /PathToProject/posts_controller.rb
   1  class PostsController < ApplicationController
   2    # GET /posts
   3    # GET /posts.xml
   4    def index
   5      debugger
=> 6      @posts = Post.find(:all)
   7
   8      respond_to do |format|
   9        format.html # index.html.erb
   10        format.xml  { render :xml => @posts }
----------------------------------------------------------------------------

Se você repetir o comando +list+, desta vez utilizando somente o `l`, as próximas dez linhas do arquivo serão impressas.

----------------------------------------------------------------------------
(rdb:7) l
[11, 20] in /PathTo/project/app/controllers/posts_controller.rb
   11      end
   12    end
   13
   14    # GET /posts/1
   15    # GET /posts/1.xml
   16    def show
   17      @post = Post.find(params[:id])
   18
   19      respond_to do |format|
   20        format.html # show.html.erb
----------------------------------------------------------------------------

E assim por diante, até o fim do arquivo atual. Quando chegar ao final do arquivo, o comando +list+ irá continuar do começo do arquivo e seguir novamente até seu final, tratando o arquivo como um buffer cíclico.

=== O Contexto

Enquanto você estiver depurando a sua aplicação, você será colocado em diferentes contextos quando passar por diferentes partes da pilha de execução.

O ruby-debug cria conteúdo quando um ponto de parada é alcançado ou quando um evento ocorre. O contexto possui informações sobre o programa paralisado, o que permite ao depurador obter informações sobre a pilha de execução, verificar valores de variáveis na perspectiva do programa depurado, e contém informações sobre o local onde o programa sendo depurado foi paralisado.

A qualquer momento você pode chamar o comando `backtrace` (ou o seu atalho `where`) para imprimir o backtrace (rastros) de sua aplicação. Isto pode ser muito útil para descobrir como você chegou onde está agora. Se você em algum momento se perguntou como chegou a algum lugar em seu código, o comando `backtrace` lhe dará a resposta.

----------------------------------------------------------------------------
(rdb:5) where
    #0 PostsController.index
       at line /PathTo/project/app/controllers/posts_controller.rb:6
    #1 Kernel.send
       at line /PathTo/project/vendor/rails/actionpack/lib/action_controller/base.rb:1175
    #2 ActionController::Base.perform_action_without_filters
       at line /PathTo/project/vendor/rails/actionpack/lib/action_controller/base.rb:1175
    #3 ActionController::Filters::InstanceMethods.call_filters(chain#ActionController::Fil...,...)
       at line /PathTo/project/vendor/rails/actionpack/lib/action_controller/filters.rb:617
...
----------------------------------------------------------------------------

Você pode mover-se dentro dos rastros (alterando seu contexto) utilizando o comando `frame _n_`, onde _n_ é o número do frame desejado.

----------------------------------------------------------------------------
(rdb:5) frame 2
#2 ActionController::Base.perform_action_without_filters
       at line /PathTo/project/vendor/rails/actionpack/lib/action_controller/base.rb:1175
----------------------------------------------------------------------------

As variáveis disponíveis são as mesmas que você tem ao executar o código linha por linha. Afinal, isto é o que uma depuração significa.

Movendo-se na pilha: Você pode utilizar os comandos `up [n]` (abreviação `u`) e `down [n]` para alterar o contexto para _n_ frames para cima ou para baixo, respectivamente. O padrão para _n_ é um. Para cima, neste caso, é em direção aos frames de número mais altos, e para baixo é em direção aos de número mais baixos.

=== Threads

O depurador pode listar, parar, continuar e alterar entre threads sendo executadas utilizando o comando `thread` (ou sua abreviação `th`). Este comando possui as seguintes opções:

* `thread` mostra a thread atual.
* `thread list` é utilizado para listar todas as threads e seus estados. O caracter mais (+) e o número indicam a thread em execução.
* `thread stop _n_` para a thread _n_.
* `thread resume _n_` continua a thread _n_.
* `thread switch _n_` altera o contexto atual para o da thread _n_.

Este comando é muito útil, dentre outras situações, para quando você estiver depurando threads concorrentes e você quiser verificar se existem disputas de condições em seu código.

=== Inspecionando Variáveis

Qualquer expressão pode ser avaliada no contexto atual. Para avaliar uma expressão, simplesmente digite-a!

Este exemplo mostra como você pode imprimir as variáveis de instância (instance_variables) definidas no contexto atual:

----------------------------------------------------------------------------
@posts = Post.find(:all)
(rdb:11) instance_variables
["@_response", "@action_name", "@url", "@_session", "@_cookies", "@performed_render", "@_flash", "@template", "@_params", "@before_filter_chain_aborted", "@request_origin", "@_headers", "@performed_redirect", "@_request"]
----------------------------------------------------------------------------

Como você pode ver, todas as variáveis acessíveis de um controller são mostradas. Esta lista é atualizada dinamicamente enquanto você executa código. Por exemplo, execute a próxima linha utilizando o comando `next` (você aprenderá mais sobre este comando mais adiante).

----------------------------------------------------------------------------
(rdb:11) next
Processing PostsController#index (for 127.0.0.1 at 2008-09-04 19:51:34) [GET]
  Session ID: BAh7BiIKZmxhc2hJQzonQWN0aW9uQ29udHJvbGxlcjo6Rmxhc2g6OkZsYXNoSGFzaHsABjoKQHVzZWR7AA==--b16e91b992453a8cc201694d660147bba8b0fd0e
  Parameters: {"action"=>"index", "controller"=>"posts"}
/PathToProject/posts_controller.rb:8
respond_to do |format|
-------------------------------------------------------------------------------

E então solicite novamente as variáveis de instância:

----------------------------------------------------------------------------
(rdb:11) instance_variables.include? "@posts"
true
----------------------------------------------------------------------------

Agora +@posts+ está incluído nas variáveis de instância, pois a linha que o define foi executada.

[TIP]
Você também pode entrar no modo *irb* com o comando `irb` (claro!). Assim, uma sessão irb será iniciada a partir do contexto em que você a invocou. Mas atenção: este modo ainda esta em fase experimental.

O método `var` é a forma mais conveniente para mostrar variáveis e seus valores:

----------------------------------------------------------------------------
var
(rdb:1) v[ar] const <object>            mostra constantes de um objeto
(rdb:1) v[ar] g[lobal]                  mostra variáveis globais
(rdb:1) v[ar] i[nstance] <object>       mostra variáveis de instância de um objeto
(rdb:1) v[ar] l[ocal]                   mostra variáveis locais
----------------------------------------------------------------------------

Esta é uma ótima forma de inspecionar valores de variáveis no contexto atual. Por exemplo:

----------------------------------------------------------------------------
(rdb:9) var local
  __dbg_verbose_save => false
----------------------------------------------------------------------------

Você também pode inspecionar um método de um objeto desta forma:

----------------------------------------------------------------------------
(rdb:9) var instance Post.new
@attributes = {"updated_at"=>nil, "body"=>nil, "title"=>nil, "published"=>nil, "created_at"...
@attributes_cache = {}
@new_record = true
----------------------------------------------------------------------------

[TIP]
Os comandos `p` (print - imprimir) e `pp` (pretty print - melhor impressão) podem ser utilizados para avaliar expressões Ruby e mostrar os valores de variáveis no console.

Você também pode utilizar o comando `display` para observar variáveis. Esta é uma boa forma de avaliar os valores de uma variável enquanto o código é executado.

----------------------------------------------------------------------------
(rdb:1) display @recent_comments
1: @recent_comments =
----------------------------------------------------------------------------

As variáveis dentro da lista de observações serão impressas com seus valores assim que você avançar na pilha de execução. Para parar a observação de uma variável, utilize `undisplay _n_`, onde _n_ é o número da variável (1 no último exemplo).

=== Step by Step

Now you should know where you are in the running trace and be able to print the available variables. But lets continue and move on with the application execution.

Use `step` (abbreviated `s`) to continue running your program until the next logical stopping point and return control to ruby-debug.

[TIP]
You can also use `step+ _n_` and `step- _n_` to move forward or backward _n_ steps respectively.

You may also use `next` which is similar to step, but function or method calls that appear within the line of code are executed without stopping. As with step, you may use plus sign to move _n_ steps.

The difference between `next` and `step` is that `step` stops at the next line of code executed, doing just a single step, while `next` moves to the next line without descending inside methods.

For example, consider this block of code with an included +debugger+ statement:

[source, ruby]
----------------------------------------------------------------------------
class Author < ActiveRecord::Base
  has_one :editorial
  has_many :comments

  def find_recent_comments(limit = 10)
    debugger
    @recent_comments ||= comments.find(
      :all,
      :conditions => ["created_at > ?", 1.week.ago],
      :limit => limit
    )
  end
end
----------------------------------------------------------------------------

[TIP]
You can use ruby-debug while using script/console. Just remember to `require "ruby-debug"` before calling the `debugger` method.

----------------------------------------------------------------------------
/PathTo/project $ script/console
Loading development environment (Rails 2.1.0)
>> require "ruby-debug"
=> []
>> author = Author.first
=> #<Author id: 1, first_name: "Bob", last_name: "Smith", created_at: "2008-07-31 12:46:10", updated_at: "2008-07-31 12:46:10">
>> author.find_recent_comments
/PathTo/project/app/models/author.rb:11
)
----------------------------------------------------------------------------

With the code stopped, take a look around:

----------------------------------------------------------------------------
(rdb:1) list
[6, 15] in /PathTo/project/app/models/author.rb
   6      debugger
   7      @recent_comments ||= comments.find(
   8        :all,
   9        :conditions => ["created_at > ?", 1.week.ago],
   10        :limit => limit
=> 11      )
   12    end
   13  end
----------------------------------------------------------------------------

You are at the end of the line, but... was this line executed? You can inspect the instance variables.

----------------------------------------------------------------------------
(rdb:1) var instance
@attributes = {"updated_at"=>"2008-07-31 12:46:10", "id"=>"1", "first_name"=>"Bob", "las...
@attributes_cache = {}
----------------------------------------------------------------------------

+@recent_comments+ hasn't been defined yet, so it's clear that this line hasn't been executed yet. Use the +next+ command to move on in the code:

----------------------------------------------------------------------------
(rdb:1) next
/PathTo/project/app/models/author.rb:12
@recent_comments
(rdb:1) var instance
@attributes = {"updated_at"=>"2008-07-31 12:46:10", "id"=>"1", "first_name"=>"Bob", "las...
@attributes_cache = {}
@comments = []
@recent_comments = []
----------------------------------------------------------------------------

Now you can see that the +@comments+ relationship was loaded and @recent_comments defined because the line was executed.

If you want to go deeper into the stack trace you can move single `steps`, through your calling methods and into Rails code. This is one of the best ways to find bugs in your code, or perhaps in Ruby or Rails.

=== Breakpoints

A breakpoint makes your application stop whenever a certain point in the program is reached. The debugger shell is invoked in that line.

You can add breakpoints dynamically with the command `break` (or just `b`). There are 3 possible ways of adding breakpoints manually:

* `break line`: set breakpoint in the _line_ in the current source file.
* `break file:line [if expression]`: set breakpoint in the _line_ number inside the _file_. If an _expression_ is given it must evaluated to _true_ to fire up the debugger.
* `break class(.|\#)method [if expression]`: set breakpoint in _method_ (. and \# for class and instance method respectively) defined in _class_. The _expression_ works the same way as with file:line.

----------------------------------------------------------------------------
(rdb:5) break 10
Breakpoint 1 file /PathTo/project/vendor/rails/actionpack/lib/action_controller/filters.rb, line 10
----------------------------------------------------------------------------

Use `info breakpoints _n_` or `info break _n_` to list breakpoints. If you supply a number, it lists that breakpoint. Otherwise it lists all breakpoints.

----------------------------------------------------------------------------
(rdb:5) info breakpoints
Num Enb What
  1 y   at filters.rb:10
----------------------------------------------------------------------------

To delete breakpoints: use the command `delete _n_` to remove the breakpoint number _n_. If no number is specified, it deletes all breakpoints that are currently active..

----------------------------------------------------------------------------
(rdb:5) delete 1
(rdb:5) info breakpoints
No breakpoints.
----------------------------------------------------------------------------

You can also enable or disable breakpoints:

* `enable breakpoints`: allow a list _breakpoints_ or all of them if no list is specified, to stop your program. This is the default state when you create a breakpoint.
* `disable breakpoints`: the _breakpoints_ will have no effect on your program.

=== Catching Exceptions

The command `catch exception-name` (or just `cat exception-name`) can be used to intercept an exception of type _exception-name_ when there would otherwise be is no handler for it.

To list all active catchpoints use `catch`.

=== Resuming Execution

There are two ways to resume execution of an application that is stopped in the debugger:

* `continue` [line-specification] (or `c`): resume program execution, at the address where your script last stopped; any breakpoints set at that address are bypassed. The optional argument line-specification allows you to specify a line number to set a one-time breakpoint which is deleted when that breakpoint is reached.
* `finish` [frame-number] (or `fin`): execute until the selected stack frame returns. If no frame number is given, the application will run until the currently selected frame returns. The currently selected frame starts out the most-recent frame or 0 if no frame positioning (e.g up, down or frame) has been performed. If a frame number is given it will run until the specified frame returns.

=== Editing

Two commands allow you to open code from the debugger into an editor:

* `edit [file:line]`: edit _file_ using the editor specified by the EDITOR environment variable. A specific _line_ can also be given.
* `tmate _n_` (abbreviated `tm`): open the current file in TextMate. It uses n-th frame if _n_ is specified.

=== Quitting

To exit the debugger, use the `quit` command (abbreviated `q`), or its alias `exit`.

A simple quit tries to terminate all threads in effect. Therefore your server will be stopped and you will have to start it again.

=== Settings

There are some settings that can be configured in ruby-debug to make it easier to debug your code. Here are a few of the available options:

* `set reload`: Reload source code when changed.
* `set autolist`: Execute `list` command on every breakpoint.
* `set listsize _n_`: Set number of source lines to list by default to _n_.
* `set forcestep`: Make sure the `next` and `step` commands always move to a new line

You can see the full list by using `help set`. Use `help set _subcommand_` to learn about a particular +set+ command.

[TIP]
You can include any number of these configuration lines inside a `.rdebugrc` file in your HOME directory. ruby-debug will read this file every time it is loaded. and configure itself accordingly.

Here's a good start for an `.rdebugrc`:

----------------------------------------------------------------------------
set autolist
set forcestep
set listsize 25
----------------------------------------------------------------------------

== Debugging Memory Leaks

A Ruby application (on Rails or not), can leak memory - either in the Ruby code or at the C code level.

In this section, you will learn how to find and fix such leaks by using Bleak House and Valgrind debugging tools.

=== BleakHouse

link:http://github.com/fauna/bleak_house/tree/master[BleakHouse] is a library for finding memory leaks.

If a Ruby object does not go out of scope, the Ruby Garbage Collector won't sweep it since it is referenced somewhere. Leaks like this can grow slowly and your application will consume more and more memory, gradually affecting the overall system performance. This tool will help you find leaks on the Ruby heap.

To install it run:

----------------------------------------------------------------------------
sudo gem install bleak_house
----------------------------------------------------------------------------

Then setup you application for profiling. Then add the following at the bottom of config/environment.rb:

[source, ruby]
----------------------------------------------------------------------------
require 'bleak_house' if ENV['BLEAK_HOUSE']
----------------------------------------------------------------------------

Start a server instance with BleakHouse integration:

----------------------------------------------------------------------------
RAILS_ENV=production BLEAK_HOUSE=1 ruby-bleak-house ./script/server
----------------------------------------------------------------------------

Make sure to run a couple hundred requests to get better data samples, then press `CTRL-C`. The server will stop and Bleak House will produce a dumpfile in `/tmp`:

----------------------------------------------------------------------------
** BleakHouse: working...
** BleakHouse: complete
** Bleakhouse: run 'bleak /tmp/bleak.5979.0.dump' to analyze.
----------------------------------------------------------------------------
 
To analyze it, just run the listed command. The top 20 leakiest lines will be listed: 

----------------------------------------------------------------------------
  191691 total objects
  Final heap size 191691 filled, 220961 free
  Displaying top 20 most common line/class pairs
  89513 __null__:__null__:__node__
  41438 __null__:__null__:String
  2348 /opt/local//lib/ruby/site_ruby/1.8/rubygems/specification.rb:557:Array
  1508 /opt/local//lib/ruby/gems/1.8/specifications/gettext-1.90.0.gemspec:14:String
  1021 /opt/local//lib/ruby/gems/1.8/specifications/heel-0.2.0.gemspec:14:String
   951 /opt/local//lib/ruby/site_ruby/1.8/rubygems/version.rb:111:String
   935 /opt/local//lib/ruby/site_ruby/1.8/rubygems/specification.rb:557:String
   834 /opt/local//lib/ruby/site_ruby/1.8/rubygems/version.rb:146:Array
  ...
----------------------------------------------------------------------------

This way you can find where your application is leaking memory and fix it.

If link:http://github.com/fauna/bleak_house/tree/master[BleakHouse] doesn't report any heap growth but you still have memory growth, you might have a broken C extension, or real leak in the interpreter. In that case, try using Valgrind to investigate further.

=== Valgrind

link:http://valgrind.org/[Valgrind] is a Linux-only application for detecting C-based memory leaks and race conditions.

There are Valgrind tools that can automatically detect many memory management and threading bugs, and profile your programs in detail. For example, a C extension in the interpreter calls `malloc()` but is doesn't properly call `free()`, this memory won't be available until the app terminates.

For further information on how to install Valgrind and use with Ruby, refer to link:http://blog.evanweaver.com/articles/2008/02/05/valgrind-and-ruby/[Valgrind and Ruby] by Evan Weaver.

== Plugins for Debugging

There are some Rails plugins to help you to find errors and debug your application. Here is a list of useful plugins for debugging:

* link:http://github.com/drnic/rails-footnotes/tree/master[Footnotes]: Every Rails page has footnotes that give request information and link back to your source via TextMate.
* link:http://github.com/ntalbott/query_trace/tree/master[Query Trace]: Adds query origin tracing to your logs.
* link:http://github.com/dan-manges/query_stats/tree/master[Query Stats]: A Rails plugin to track database queries. 
* link:http://code.google.com/p/query-reviewer/[Query Reviewer]: This rails plugin not only runs "EXPLAIN" before each of your select queries in development, but provides a small DIV in the rendered output of each page with the summary of warnings for each query that it analyzed.
* link:http://github.com/rails/exception_notification/tree/master[Exception Notifier]: Provides a mailer object and a default set of templates for sending email notifications when errors occur in a Rails application.
* link:http://github.com/defunkt/exception_logger/tree/master[Exception Logger]: Logs your Rails exceptions in the database and provides a funky web interface to manage them.

== References

* link:http://www.datanoise.com/ruby-debug[ruby-debug Homepage]
* link:http://www.sitepoint.com/article/debug-rails-app-ruby-debug/[Article: Debugging a Rails application with ruby-debug]
* link:http://brian.maybeyoureinsane.net/blog/2007/05/07/ruby-debug-basics-screencast/[ruby-debug Basics screencast]
* link:http://railscasts.com/episodes/54-debugging-with-ruby-debug[Ryan Bate's ruby-debug screencast]
* link:http://railscasts.com/episodes/24-the-stack-trace[Ryan Bate's stack trace screencast]
* link:http://railscasts.com/episodes/56-the-logger[Ryan Bate's logger screencast]
* link:http://bashdb.sourceforge.net/ruby-debug.html[Debugging with ruby-debug]
* link:http://cheat.errtheblog.com/s/rdebug/[ruby-debug cheat sheet]
* link:http://wiki.rubyonrails.org/rails/pages/HowtoConfigureLogging[Ruby on Rails Wiki: How to Configure Logging]
* link:http://blog.evanweaver.com/files/doc/fauna/bleak_house/files/README.html[Bleak House Documentation]

== Changelog ==

http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/5[Lighthouse ticket]

* November 3, 2008: Accepted for publication. Added RJS, memory leaks and plugins chapters by link:../authors.html#miloops[Emilio Tagua]
* October 19, 2008: Copy editing pass by link:../authors.html#mgunderloy[Mike Gunderloy]
* September 16, 2008: initial version by link:../authors.html#miloops[Emilio Tagua]
