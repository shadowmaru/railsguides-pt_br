O Guia de Associações do Active Record
=====================================

Este guia aborda as características de associação do ActiveRecord. Ao estudar este guia, você será capaz de:

* Declarar associações entre os Models do ActiveRecord.
* Compreender os diferentes tipos de associações do ActiveRecord.
* Utilizar os métodos adicionados aos seus modelos através das associações criadas.

== Associações, Por quê?

Por que precisamos de associações entre os modelos? Porque tornam mais fácil e mais simples operações comuns no código. Considere, por exemplo, uma simples aplicação Rails que inclui um modelo para os clientes e um modelo para as encomendas. Cada cliente pode ter muitas encomendas. Sem as associações, os modelos de declarações seriam mais ou menos assim:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
end

class Order < ActiveRecord::Base
end
-------------------------------------------------------

Agora, suponha se quisesse acrescentar uma nova encomenda de um cliente existente. Gostaríamos de fazer algo parecido com isto:

[source, ruby]
-------------------------------------------------------
@order = Order.create(:order_date => Time.now, :customer_id => @customer.id)
-------------------------------------------------------

Ou apagar um cliente, e garantindo que todas as suas encomendas fossem excluídas também:

[source, ruby]
-------------------------------------------------------
@orders = Order.find_by_customer_id(@customer.id)
@orders.each do |order|
  order.destroy
end
@customer.destroy
-------------------------------------------------------

Com as associações do ActiveRecord, podemos simplificar - e outras - operações por declarações dizendo que existe uma conexão entre os dois modelos. Veja abaixo o código revisado para a criação de clientes e encomendas:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders
end

class Order < ActiveRecord::Base
  belongs_to :customer
end
-------------------------------------------------------

Com essa mudança, criando uma nova ordem para um determinado cliente é mais fácil:

[source, ruby]
-------------------------------------------------------
@order = @customer.orders.create(:order_date => Time.now)
-------------------------------------------------------

Excluindo um cliente e todas as suas encomendas é _muito_ mais fácil:

[source, ruby]
-------------------------------------------------------
@customer.destroy
-------------------------------------------------------

Para saber mais sobre os diferentes tipos de associações, leia a próxima seção deste Guia. Seguido por alguns truques e dicas para trabalhar com as associações e, em seguida, por uma referência completa para os métodos e opções para as associações em Rails.

== Os tipos de associações

Em Rails, uma _associação_ é uma conexão entre os dois modelos do ActiveRecord. As associações são implementadas usando macro de chamadas, de modo que você pode adicionar funcionalidades nos seus modelos. Por exemplo, declarando que um modelo possui +belongs_to+ com outro, você instrui o Rails a manter as informações de Chave Primária entre instâncias dos dois modelos, e você também receberá um número métodos úteis adicionado ao seu modelo. Rails suporta seis tipos de associação:

* +belongs_to+
* +has_one+
* +has_many+
* +has_many :through+
* +has_one :through+
* +has_and_belongs_to_many+

No restante deste guia, você aprenderá a declarar e utilizar as diversas formas de associações. Mas, primeiro, uma introdução rápida a situações em que cada tipo de associação é adequado.

=== Associação +belongs_to+

Uma associação +belongs_to+ cria uma conexão um-para-um com outro modelo, de modo a que cada instância do modelo com a declaração _“pertence a”_ uma instancia de um outro modelo. Por exemplo, se sua aplicação incluir clientes e encomendas, e cada encomenda pode ser atribuído exatamente um cliente, você declararia o modelo desta forma:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer
end
-------------------------------------------------------

image:images/belongs_to.png[belongs_to Association Diagram]

=== A Associação +has_one+

A associação +has_one+ também prevê a criação de uma conexão um-para-um com outro modelo, mas com uma semântica um pouco diferente (e conseqüências). Esta associação indica que cada instância de um modelo contém ou possui uma instancia de outro modelo. Por exemplo, se cada um fornecedor na sua aplicação possui somente uma conta, você iria declarar o modelo fornecedor como este:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account
end
-------------------------------------------------------

image:images/has_one.png[has_one Association Diagram]

=== A Associação +has_many+

Uma associação +has_many+ indica uma conexão um-para-muitos com outro modelo. Você irá encontrar muitas vezes esta associação do _“outro lado”_ de uma associação +belongs_to+. Esta associação indica que cada instância do modelo possui uma ou mais instancias do outro modelo. Por exemplo, em uma aplicação contendo clientes e encomendas, o modelo cliente deve ser declarado como este:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

NOTE: O nome do outro modelo é pluralizado quando declarado uma associação +has_many+.

image:images/has_many.png[has_many Association Diagram]

=== A Associação +has_many :through+

Um associação +has_many :through+ é freqüentemente utilizado para criar um conexão muitos-para-muitos com outro modelo. Esta associação indica que a declaração do modelo possa ser compensada com zero ou mais instancias de outro modelo _“através de”_  um processo de um terceiro modelo. Por exemplo, considere uma prática médica onde pacientes podem marcar para ver médicos. As declarações relevantes da associação devem ser semelhantes a este:

[source, ruby]
-------------------------------------------------------
class Physician < ActiveRecord::Base
  has_many :appointments
  has_many :patients, :through => :appointments
end

class Appointment < ActiveRecord::Base
  belongs_to :physician
  belongs_to :patient
end

class Patient < ActiveRecord::Base
  has_many :appointments
  has_many :physicians, :through => :appointments
end
-------------------------------------------------------

image:images/has_many_through.png[has_many :through Association Diagram]

O associação +has_many :through+ é também útil para a criação de _“atalhos”_ através de associações +has_many+ aninhadas. Por exemplo, se um documento tem muitas seções, e uma seção possui muitos parágrafos, você pode algumas vezes pegar uma simples coleção de todos os parágrafos no documento. Você poderia declarar desta forma:

[source, ruby]
-------------------------------------------------------
class Document < ActiveRecord::Base
  has_many :sections
  has_many :paragraphs, :through => :sections
end

class Section < ActiveRecord::Base
  belongs_to :document
  has_many :paragraphs
end

class Paragraph < ActiveRecord::Base
  belongs_to :section
end
-------------------------------------------------------

=== A Associação +has_one: through+

Uma associação +has_one :through+ cria uma conexão de um-para-um com outro modelo. Esta associação indica que a declaração do modelo possa ser combinada com uma instancia de outro modelo _através_ de um terceiro modelo. Por exemplo, se cada fornecedor possui uma conta, e cada conta está associada a um histórico da conta, então o modelo cliente poderá ser declarado desta forma:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account
  has_one :account_history, :through => :account
end

class Account < ActiveRecord::Base
  belongs_to :supplier
  has_one :account_history
end

class AccountHistory < ActiveRecord::Base
  belongs_to :account
end
-------------------------------------------------------

image:images/has_one_through.png[has_one :through Association Diagram]

=== A Associação +has_and_belongs_to_many+

Uma associação +has_and_belongs_to_many+ cria uma conexão direta muitos-para-muitos com outro modelo, sem intervir no modelo. Por exemplo, se a sua aplicação incluir peças e conjuntos, onde cada conjunto inclui várias peças e que cada peça aparece em muitos conjuntos, você poderia declarar os modelos desta maneira:

[source, ruby]
-------------------------------------------------------
class Assembly < ActiveRecord::Base
  has_and_belongs_to_many :parts
end

class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end
-------------------------------------------------------

image:images/habtm.png[has_and_belongs_to_many Association Diagram]

=== Escolhendo Entre +belongs_to+ e +has_one+

Se você deseja criar uma relação 1×1 entre dois modelos, será necessário adicionar a um +belongs_to+ e ao outro +has_one+. Como você sabe quem é quem?

A distinção está no lugar onde você colocou a chave estrangeira (ele fica na tabela da classe que foi declarada a associação +belongs_to+), mas você deveria refletir um pouco mais sobre o real significado desses dados. O relacionamento +has_one+ fala alguma coisa para os seus - ou seja, algo que aponta de volta para você. Por exemplo, faz mais sentido dizer que um fornecedor possui uma conta do que uma conta que possui um fornecedor. Isso sugere que o relacionamento correto é algo como este:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account
end

class Account < ActiveRecord::Base
  belongs_to :supplier
end
-------------------------------------------------------

A migração correspondente se parece com isso:

[source, ruby]
-------------------------------------------------------
class CreateSuppliers < ActiveRecord::Migration
  def self.up
    create_table :suppliers do |t|
      t.string  :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.integer :supplier_id
      t.string  :account_number
      t.timestamps
    end
  end

  def self.down
    drop_table :accounts
    drop_table :suppliers
  end
end
-------------------------------------------------------

NOTE: Usando +t.integer :supplier_id+ faz a nomeação da chave estrangeira óbvia e implicitamente. Nas versões atuais do Rails, você pode abstrair a implementação deste detalhe usando +t.references :supplier+.

=== Escolhendo Entre +has_many :through+ e +has_and_belongs_to_many+

Rails oferece duas maneiras diferentes para declarar um relacionamento muitos-para-muitos entre modelos. A maneira mais simples é usar +has_and_belongs_to_many+, que permite que você faça a associação diretamente:

[source, ruby]
-------------------------------------------------------
class Assembly < ActiveRecord::Base
  has_and_belongs_to_many :parts
end

class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end
-------------------------------------------------------

A segunda forma de declarar o relacionamento muitos-para-muitos é usar +has_many :through+. Isto faz com que crie uma associação indiretamente, através de um join no modelo:

[source, ruby]
-------------------------------------------------------
class Assembly < ActiveRecord::Base
  has_many :manifests
  has_many :parts, :through => :manifests
end

class Manifest < ActiveRecord::Base
  belongs_to :assembly
  belongs_to :part
end

class Part < ActiveRecord::Base
  has_many :manifests
  has_many :assemblies, :through => :manifests
end
-------------------------------------------------------

A regra é simples, você deve criar um relacionamento +has_many :through+ se você precisa trabalhar com o relacionamento do modelo como uma entidade independente. Se você não precisa fazer nada com relacionamento do modelo, pode ser mais simples se criar um relacionamento +has_and_belongs_to_many+ (mas você precisa se lembrar se precisa criar joins nas tabelas).

Você deve usar +has_many :through+ se você precisar de validações, callbacks (chamadas), ou atributos extras no join do modelo.

=== Associações polimórficas

Um pouco mais avançado é o twist em _associações polimórficas. Com associações Polimórficas, um modelo pode pertencer a mais de um modelo, em uma única associação. Por exemplo, imagine que você possa ter um modelo foto que pertence a um empregado ou ao modelo produto. Veja como isso poderia ser declarada:

[source, ruby]
-------------------------------------------------------
class Picture < ActiveRecord::Base
  belongs_to :imageable, :polymorphic => true
end

class Employee < ActiveRecord::Base
  has_many :pictures, :as => :imageable
end

class Product < ActiveRecord::Base
  has_many :pictures, :as => :imageable
end
-------------------------------------------------------

Você pode pensar em uma declaração +belongs_to+ polimórfica criando uma interface que pode ser usada por qualquer outro modelo. A partir de uma instância do modelo +Employee+, você pode recuperar uma coleção de fotos: +@employee.pictures+. Da mesma forma, você pode usar +@product.pictures+. Se você tem uma instancia do modelo Picture você pode pegar seu pai através +@picture.imageable+. Para que isto funcione, você necessita declarar tanto uma coluna chave estrangeira e uma coluna tipo no modelo declarado com uma interface polimórficas:

[source, ruby]
-------------------------------------------------------
class CreatePictures < ActiveRecord::Migration
  def self.up
    create_table :pictures do |t|
      t.string  :name
      t.integer :imageable_id
      t.string  :imageable_type
      t.timestamps
    end
  end

  def self.down
    drop_table :pictures
  end
end
-------------------------------------------------------

Esta migração pode ser simplificada utilizando o formulário +t.references+:

[source, ruby]
-------------------------------------------------------
class CreatePictures < ActiveRecord::Migration
  def self.up
    create_table :pictures do |t|
      t.string  :name
      t.references :imageable, :polymorphic => true
      t.timestamps
    end
  end

  def self.down
    drop_table :pictures
  end
end
-------------------------------------------------------

image:images/polymorphic.png[Polymorphic Association Diagram]

=== Self Joins

Na criação de um modelo de dados, às vezes você irá encontrar um modelo que deverá ter uma relação a si própria. Por exemplo, você pode armazenar todos os empregados em uma única base de dados, mas ser capaz de rastrear relacionamentos como gerentes e subordinados. Esta situação pode ser modelada com as associações com ele mesmo:

[source, ruby]
-------------------------------------------------------
class Employee < ActiveRecord::Base
  has_many :subordinates, :class_name => "User", :foreign_key => "manager_id"
  belongs_to :manager, :class_name => "User"
end
-------------------------------------------------------

Com essa configuração, você pode utilizar +@employee.subordinates+ e +@employee.manager+.

== Dicas, Truques e Avisos

Aqui algumas coisas que você deve saber para fazer um uso eficiente das associações do Active Record em suas aplicações Rails:

* Controlando Caching
* Evitando colisões com nomes
* Atualizando o schema
* Controlando o escopo das associações

=== Controlando Caching

Todos os métodos de associação são construídos em torno de um caching que mantém o resultado das queries recentes disponíveis para futuras operações. O cache é compartilhado mesmo entre métodos. Por exemplo:

[source, ruby]
-------------------------------------------------------
customer.orders                 # retornar todas as orders(encomendas) do banco de dados
customer.orders.size            # usa a cópia no cache de orders
customer.orders.empty?          # usa a cópia no cache de orders
-------------------------------------------------------

Mas e se você quiser recarregar o cache, porque seus dados foram alterados em outra parte da aplicação? Apenas passe +true+ para a chamada da associação:

[source, ruby]
-------------------------------------------------------
customer.orders                 # retornar todas as orders(encomendas) do banco de dados
customer.orders.size            # usa a cópia no cache de orders
customer.orders(true).empty?    # desconsidera a copia do cache e faz a busca no banco de dados novamente
-------------------------------------------------------

=== Evitando colisões com nomes

Você não é livre para usar qualquer nome para suas associações. Porque criando uma associação é criado um método com este nome do model, é uma péssima idéia usar um nome de associação que já foi usado para um método de instância para +ActiveRecord::Base+ . O método de associação iria sobrescrever o método inicial e quebrar as coisas. Então, +attributes+ ou +connection+ são nomes impróprios para associações.

=== Atualizando o schema

Associações são extremamente úteis, mas não são mágicas. Você é responsável por manter seu esquema do banco de dados sincronizado com suas associações. Na prática, isto significa duas coisas. Primeiro, você deve criar as chaves estrangeiras apropriadas:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer
end
-------------------------------------------------------

Esta declaração precisar ser suportada pela devida declaração de chave estrangeira na tabela orders:

[source, ruby]
-------------------------------------------------------
class CreateOrders < ActiveRecord::Migration
  def self.up
    create_table :orders do |t|
      t.order_date   :datetime
      t.order_number :string
      t.customer_id  :integer
    end
  end

  def self.down
    drop_table :orders
  end
end
-------------------------------------------------------

Se você criar alguma associação depois que você tiver construído o respectivo model, você precisa se lembrar de criar um migradtion +add_column+ para prover a chave estrangeira adequada.

Segundo, se você criar uma associação +has_and_belongs_to_many+ , você precisa explicitamente criar uma tabela para o join. A menos que o nome da tabela para o join seja explicitamente especificada usando a opção +:join_table+ , Active Record cria o nome usando uma ordem léxica de acordo com os nomes das classes. Então uma associação entre os modelos customer e order irá gerar uma tabela para a junção com o nome "customers_orders" porque o "c" é superior ao "o" no ordenamento léxico.

WARNING: A precedência entre nomes de modelos é calcular usando o operado +<+ para +String+. O que significa que as strings são de tamanhos diferentes, e a string é menor quando comparada com outra com tamanho menor, então a string maior será considerada com maior precedência léxica que a menor. Por exemplo, seria de se esperar que as tabelas "paper_boxes" e "papers" iriam gerar uma tabela de associação com o "papers_paper_boxes" por causa do tamanho de "paper_boxes", mas de fato o nome da tabela de associação será "paper_boxes_papers".

Independente do nome, você deve gerar manualmente a tabela de associação com uma migration apropriada. Por exemplo, considere esta associação:

[source, ruby]
-------------------------------------------------------
class Assembly < ActiveRecord::Base
  has_and_belongs_to_many :parts
end

class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end
-------------------------------------------------------

Este código precisa ser contemplado por uma migration para criar a tabela +assemblies_parts+ . Esta tabela deve ser criada sem uma primary key (chave primária)

[source, ruby]
-------------------------------------------------------
class CreateAssemblyPartJoinTable < ActiveRecord::Migration
  def self.up
    create_table :assemblies_parts, :id => false do |t|
      t.integer :assembly_id
      t.integer :part_id
    end
  end

  def self.down
    drop_table :assemblies_parts
  end
end
-------------------------------------------------------

=== Controlando o escopo das associações

Por padrão, associações enxergam objetos apenas no módulo atual. Isto pode ser importante quando você declara modelos Active Record dentro de um módulo. Por exemplo:

[source, ruby]
-------------------------------------------------------
module MyApplication
  module Business
    class Supplier < ActiveRecord::Base
       has_one :account
    end

    class Account < ActiveRecord::Base
       belongs_to :supplier
    end
  end
end
-------------------------------------------------------

Isto irá funcionar, porque tanto a classe +Supplier+ quanto a classe +Account+ são definidas com o mesmo escopo. Mas o código abaixo não funcionará, porque +Supplier+ e +Account+ são definidos em escopos diferentes:

[source, ruby]
-------------------------------------------------------
module MyApplication
  module Business
    class Supplier < ActiveRecord::Base
       has_one :account
    end
  end

  module Billing
    class Account < ActiveRecord::Base
       belongs_to :supplier
    end
  end
end
-------------------------------------------------------

Para associar um model com um outro model em um escopo diferente, você precisa especificar o nome completo da classe na declaração de sua associação:

[source, ruby]
-------------------------------------------------------
module MyApplication
  module Business
    class Supplier < ActiveRecord::Base
       has_one :account, :class_name => "MyApplication::Billing::Account"
    end
  end

  module Billing
    class Account < ActiveRecord::Base
       belongs_to :supplier, :class_name => "MyApplication::Business::Supplier"
    end
  end
end
-------------------------------------------------------

== Referência Detalhada sobre Associações

As seções seguintes detalham cada tipo de associação, incluindo métodos que elas adicionam e as opções que você pode usar quando estiver declarando uma associação.

=== A associação +belongs_to+

Associação +belongs_to+ (pertence á) cria um dependência de um-para-um com outro modelo. Em termos de banco de dados, esta associação diz que esta classe onde belongs_to for chamado irá conter a chave estrangeira. Mas se a outra classe contém a chave estrangeira então você deve usar +has_one+ ao invés de +belongs_to+.

==== Métodos Adicionados pelo +belongs_to+

Quando você declara uma associação +belongs_to+, a classe que declara automaticamente ganha cinco métodos relacionados a associação:

* +_association_(force_reload = false)+
* +_association_=(associate)+
* +_association_.nil?+
* +build___association__(attributes = {})+
* +create___association__(attributes = {})+

Em todos estes métodos, +_association_+ é substituído pelo símbolo passado como primeiro argumento ao +belongs_to+. Por exemplo:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer
end
-------------------------------------------------------

Cada instância do modelo order vai ter estes métodos:

[source, ruby]
-------------------------------------------------------
customer
customer=
customer.nil?
build_customer
create_customer
-------------------------------------------------------

===== +_association_(force_reload = false)+

O método +_association_+ returna o objeto associado, se existir. Se nenhum objeto associado for encontrado então, seu retorno será +nil+ .

[source, ruby]
-------------------------------------------------------
@customer = @order.customer
-------------------------------------------------------

Se o objeto associado já tiver sido buscado no banco de dados para este objeto, a versão cacheda será retornada. Para substituir esse comportamento (e force o banco de dados a ler), passe +true+ para o argumento +force_reload+ .

===== +_association_=(associate)+

O método +_association_=+ atribui um objeto associado para este objeto. Nos bastidores, isto significa buscar a chave primária do objeto associado e definir esta, como chave estrangeira para o mesmo valor.

[source, ruby]
-------------------------------------------------------
@order.customer = @customer
-------------------------------------------------------

===== +_association_.nil?+

O método +_association_.nil?+ retorna +true+ se não existir nenhum objeto associado.

[source, ruby]
-------------------------------------------------------
if @order.customer.nil?
  @msg = "No customer found for this order"
end
-------------------------------------------------------

===== +build___association__(attributes = {})+

O método +build__\_association__+ retorna um novo objeto do tipo associado. Este objeto será instanciado a partir dos atributos passados, e linkando este objeto, uma chave estrangeira será definida, mas o objeto associado ainda não será salvo.

[source, ruby]
-------------------------------------------------------
@customer = @order.build_customer({:customer_number => 123, :customer_name => "John Doe"})
-------------------------------------------------------

===== +create___association__(attributes = {})+

O método +create__\_association__+ retorna um novo objeto do tipo associado. Este objeto será instanciado a partir dos atributos passados, e linkando este objeto, uma chave estrangeira será definida. Porém, o objeto associado será salvo (assumindo que passe pelas validações).

[source, ruby]
-------------------------------------------------------
@customer = @order.create_customer({:customer_number => 123, :customer_name => "John Doe"})
-------------------------------------------------------

==== Opções para +belongs_to+

Em muitas situações, você pode usar o comportamento padrão do +belongs_to+ sem nenhuma customização. Mas apesar da ênfase que o Rails faz em convenção sobre customização, você poder alterar este comportamento de várias formas. Esta sessão cobre as opções que você pode passar quando criar uma associação +belongs_to+ . Por exemplo, uma associação com várias opções pode parecer com isto:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :counter_cache => true, :conditions => "active = 1"
end
-------------------------------------------------------

A associação +belongs_to+ suporta estas opções:

// * +:accessible+
* +:class_name+
* +:conditions+
* +:counter_cache+
* +:dependent+
* +:foreign_key+
* +:include+
* +:polymorphic+
* +:readonly+
* +:select+
* +:validate+

// ===== +:accessible+
//
// A opção +:accessible+ é a versão associativa de +ActiveRecord::Base#attr_accessible+. Se você definir a opção +:accessible+ para verdadeiro, então mass assignment // é permitido para esta associação.
//
===== +:class_name+

Se o nome do outro modelo não puder ser derivado do nome da associação, você pode usar a opção +:class_name+ para informar o nome do modelo. Por exemplo, se uma "order" pertence á um "customer", mas o nome atual do modelo que contém "customer" é +Patron+, você precisa definir desta forma:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :class_name => "Patron"
end
-------------------------------------------------------

===== +:conditions+

Opção +:conditions+ deixa você especificar as condições que o objeto associado precisa cumprir ( na sintaxe usada por uma cláusula SQL +WHERE+ ).

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :conditions => "active = 1"
end
-------------------------------------------------------

===== +:counter_cache+

A opção +:counter_cache+ pode ser usada para fazer a busca do número de objetos associados, mais eficiente. Considere estes modelos:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer
end
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

Com esta declaração, perguntando pelo valor de +@customer.orders.size+ requer uma chamada para o banco de dados para executar uma query +COUNT(*)+ . Para evitar esta chamada, você pode adicionar um contra cache ao modelo pertencente:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :counter_cache => true
end
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

Com estas declarações, Rails vai manter o valor do cache atualizado, e então retornar o valor como resposta a o método +.size+ .

Apesar da opção +:counter_cache+ ser especificada no modelo que inclui a declaração +belongs_to+, a coluna atual precisa ser adicionada ao modelo _associado_ . No caso acima, você deveria adicionar uma coluna +orders_count+ ao modelo +Customer+ . Você pode sobrescrever a nome padrão da coluna se você precisar:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :counter_cache => :count_of_orders
end
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

Colunas de counter cache são adicionadas ao model que as contém como atributos read-only através do +attr_readonly+.

===== +:dependent+

Se você definir a opção +:dependent+ para +:destroy+, então excluindo este objeto será chamado o método destroy no objeto associado para destruir este objeto. Se você definir a opção +:dependent+ para +:delete+, então excluindo este objeto irá excluir 
o objeto associado _sem_ chamar o método +destroy+ method.

WARNING: Você não deve especificar esta opção em uma associação +belong_to+ que esteja conectada com uma associação +has_many+. Se o fizer, resultará em registros orfãos em seu banco de dados.

===== +:foreign_key+

Por convenção, Rails adivinha que a coluna que será usada para guardar a chave estrangeira neste model será o nome da associação com o sufixo +_id+ . A opção +:foreign_key+ permite você definir o nome da chave estrangeira diretamente:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :class_name => "Patron", :foreign_key => "patron_id"
end
-------------------------------------------------------

TIP: Em caso algum, Rails irá criar as colunas de chave estrangeira para você. Você precisa explicitamente defini-las como parte de suas migrations.

===== +:include+

Você pode usar a opção :include para especificar as associações de segunda ordem que devem ser eager-loaded (pré-carregada) quando esta associação for utilizada. Por exemplo:

[source, ruby]
-------------------------------------------------------
class LineItem < ActiveRecord::Base
  belongs_to :order
end
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

Se você frequentemente returnar customers diretamente de line items (+@line_item.order.customer+), então você pode fazer seu código um pouco mais eficiente incluindo customers na associação de line items para orders:

[source, ruby]
-------------------------------------------------------
class LineItem < ActiveRecord::Base
  belongs_to :order, :include => :customer
end
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

NOTE: Não a necessidade de usar +:include+ para associações imediatas - significa que, se você tiver +Order belongs_to :customer+, então customer é eager-loaded(pré-carregado) automaticamente quando ele for necessário.

===== +:polymorphic+

Passando +true+ para a opção +:polymorphic+ indica que isso será uma associação polymorphic. Associações polimórficas serão discutidas em detalhes neste guia.

===== +:readonly+

Se você definir a opção +:readonly+ para +true+, então o objeto associado será de apenas leitura quando for retornado pela associação.

===== +:select+

A opção +:select+ permite que você sobrescreva a cláusula SQL +SELECT+ que é usada para retornar dados sobre o objeto associado. Por padrão, Rails retorna todas as colunas.

TIP: Se você definir a opção +:select+ em uma associação +belongs_to+ , você também deve definir a +foreign_key+ para garantir resultados corretos.

===== +:validate+

Se você definir a opção +:validate+ para +true+, então os objetos associados serão validados quando você salvar este objeto. Por padrão, esta opção é +false+:, objetos associados não serão validados quando este objeto for gravado.

==== Quando Objetos são Gravados?

Atribuir um objeto a uma associação +belongs_to+ _não_ o grava automaticamente. Isto não grava cada objeto associado. 

=== Associação has_one

A associação +has_one+ cria uma relação um-para-um com outro model. Se tratando de banco de dados, esta associação diz que a outra classe terá a chave estrangeira. Se esta class possuir a chave estrangeira, então você deve usar um +belongs_to+ ao invés.

==== Métodos Adicionados pelo +has_one+

Quando você declara a associação +has_one+, a classe declarante automaticamente ganha cinco métodos relacionados a associação:

* +_association_(force_reload = false)+
* +_association_=(associate)+
* +_association_.nil?+
* +build___association__(attributes = {})+
* +create___association__(attributes = {})+

Em todos estes métodos, +_association_+ são substituídos pelo símbolo passado como o primeiro argumento do método +has_one+ . Por exemplo,  a declaração abaixo:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account
end
-------------------------------------------------------

Cada instância do model +Supplier+ irá conter os seguintes métodos:

[source, ruby]
-------------------------------------------------------
account
account=
account.nil?
build_account
create_account
-------------------------------------------------------

===== +_association_(force_reload = false)+

O método +_association_+ retorna o objeto associado, se houver algum. Se nenhum objeto associado for encontrado, retornará +nil+.

[source, ruby]
-------------------------------------------------------
@account = @supplier.account
-------------------------------------------------------

Se o objeto associado já tiver sido buscado do banco de dados para este objeto (@supplier), a versão cacheada será retornada. Para sobrescrever este comportamento ( e força a leitura do banco de dados), passe +true+ para o argumento +force_reload+ . 

===== +_association_=(associate)+

O método +_association_=+ atribui um objeto associado a esta associação. Por trás dos panos, isto significa extrair a chave primária do objeto e definir a chave estrangeira do objeto associado ao mesmo valor.

[source, ruby]
-------------------------------------------------------
@suppler.account = @account
-------------------------------------------------------

===== +_association_.nil?+

O método +_association_.nil?+ retorna +true+ se não houver nenhum objeto associado.

[source, ruby]
-------------------------------------------------------
if @supplier.account.nil?
  @msg = "No account found for this supplier"
end
-------------------------------------------------------

===== +build___association__(attributes = {})+

O método +build__\_association__+  retorna um novo objeto do tipo associado. Este objeto será instanciado a partir do atributos passados, e será associado através de sua chave estrangeira, mas o objeto associado não será gravado.

[source, ruby]
-------------------------------------------------------
@account = @supplier.build_account({:terms => "Net 30"})
-------------------------------------------------------

===== +create___association__(attributes = {})+

O método +create__\_association__+ retorna um novo objeto do tipo associado. Este objeto será instanciado a partir do atributos passados, e será associado através de sua chave estrangeira. Porém, o objeto associado _será_ gravado ( assumindo que ele passe por todas as validações).

[source, ruby]
-------------------------------------------------------
@account = @supplier.create_account({:terms => "Net 30"})
-------------------------------------------------------

==== Options for +has_one+

Em várias situações, você pode usar o comportamento padrão do +has_one+ sem nenhuma customização. Apesar da ênfase do Rails em convenção sobre customização, você pode alterar este comportamento de várias formas. Esta seção cobre as opções que você pode passar quando criar um associação +has_one+. Por exemplo, uma associação com várias opções pode parecer com isto:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account, :class_name => "Billing", :dependent => :nullify
end
-------------------------------------------------------

A associação +has_one+ suporta essas opções:

// * +:accessible+
* +:as+
* +:class_name+
* +:conditions+
* +:dependent+
* +:foreign_key+
* +:include+
* +:order+
* +:primary_key+
* +:readonly+
* +:select+
* +:source+
* +:source_type+
* +:through+
* +:validate+

// ===== +:accessible+
//
// A opção +:accessible+ é a versão de +ActiveRecord::Base#attr_accessible+. Se você definir a opção +:accessible+ para verdadeiro, // passa a ser permitido o  mass assignment (atribuição em massa) para esta associação.
//
===== +:as+

Definindo a opção +:as+ indica que esta será uma associação polimórfica. Associações polimórficas serão discutidas mais adiante neste guia.

===== +:class_name+

Se o nome do outro modelo não puder ser adivinhado a partir do nome da associação, você pode usar a opção +:class_name+ para fornecer o nome da classe. Por exemplo, se fornecedor(supplier) possui uma conta(account), mas o nome do modelo atual que contém as contas (accounts) é Billing, você precisa definir as coisas como abaixo:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account, :class_name => "Billing"
end
-------------------------------------------------------

===== +:conditions+

A opção +:conditions+ permiti que você especifique as condições que o objeto associado deve satisfazer ( a sintaxe é usada por uma cláusula SQL +WHERE+ ).

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account, :conditions => "confirmed = 1"
end
-------------------------------------------------------

===== +:dependent+

Se você definir a opção +:dependent+ para +:destroy+, ao apagar este objeto irá chamar o método destroy no objeto associado para apagá-lo também. Se você definir a opção +:dependent+ para +:delete+, então apagando este objeto irá excluir o objeto associado _sem_ chamar o método +destroy+. Se você definir a opção +:dependent+ to +:nullify+, ao excluir este objeto irá definir a chave estrangeira do objeto associado para +NULL+. 

===== +:foreign_key+

Por convenção, Rails adivinha que a coluna usada para guardar a chave estrangeira no outro modelo é o nome do modelo com o sufixo +_id+ adicionada. A opção  +:foreign_key+ permite que você defina o nome da chave estrangeira diretamente:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account, :foreign_key => "supp_id"
end
-------------------------------------------------------

TIP: Em nenhum caso, Rails irá criar a coluna da chave estrangeira para você. Você precisa defini-la como parte de suas migrations.

===== +:include+

Você pode usar a opção :include para especificar uma associação de segunda ordem que deve ser pré carregada (eager-loaded) quando a associação for usar. Por exemplo, considere os modelos abaixo:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account
end
class Account < ActiveRecord::Base
  belongs_to :supplier
  belongs_to :representative
end
class Representative < ActiveRecord::Base
  has_many :accounts
end
-------------------------------------------------------

Se você freqüentemente buscar representantes( representatives ) a partir de fornecedores( suppliers, ex.: +@supplier.account.representative+ ), então você pode fazer seu código se tornar mais eficiente, incluindo representantes (representatives) na associação de fornecedores ( suppliers ) para contas ( accounts ):

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account, :include => :representative
end
class Account < ActiveRecord::Base
  belongs_to :supplier
  belongs_to :representative
end
class Representative < ActiveRecord::Base
  has_many :accounts
end
-------------------------------------------------------

===== +:order+

A opção +:order+ dita a ordem em que os objetos associados deverão ser retornados (em uma sintaxe usada por uma cláusula SQL +ORDER BY+). Mas como é uma associação +has_one+ vai retornar apenas um objeto, esta opção não é necessária.

===== +:primary_key+

Por convenção, Rails adivinha que a coluna que irá armazenar a chave primária será deste model é +id+. Você pode sobrescrever isto e especificar a chave primária com a opção +:primary_key+ .

===== +:readonly+

Se você definir a opção +:readonly+ para +true+, o objeto associado será exclusivamente para leitura quando for retornado pela associação.

===== +:select+

A opção +:select+ permite que você altere a cláusula SQL +SELECT+ que é usada para retornar os do objeto associado. Por padrão, Rails retorna todas as colunas.

===== +:source+

A opção +:source+  específica o nome para fonte para uma associação +has_one :through+ .

===== +:source_type+

A opção +:source_type+ específica o tipo da fonte para a associação +has_one :through+ em uma associação polimórfica.

===== +:through+

A opção +:through+ específica um model para a junção (join) para executar a query. Associações +has_one :through+ serão discutidas em detalhes mais adiante.

===== +:validate+

Se você definir a opção +:validate+ para +true+, os objetos associados serão validados sempre que você salvar este objeto. Por padrão, ele é +false+: objetos associados não serão validados quando este objeto for salvo.

==== Quando Objetos São Salvos?

Quando você atribuir um objeto a uma associação +has_one+, este objeto é automaticamente salvo(para atualizar a chave estrangeira). Além disso, qualquer objeto que estiver sendo substituído também é salvo automaticamente, porque sua chave estrangeira também será alterada.

Se qualquer uma dessas gravações falhar devido a erros de validação, então a atribuição retornará +false+ e a própria atribuição é cancelada.

Se o objeto pai (o que estiver declarando a associação +has_one+) não é salvo (isso é, +new_record?+ retorna +true+) então os objeto filhos não serão salvos.

Se você quiser atribuir um objeto para uma associação +has_one+ sem salvar o objeto, use o método +association.build+ .

=== A associação has_many

A associação +has_many+ cria uma relação um-para-muitos com outro model. Em termos de banco de dados, esta associação diz que a outra classe terá a chave estrangeira que referência a instância desta classe.

==== Métodos Adicionados

Quando você declara a  associação +has_many+, a classe declarante irá ganhar automaticamente 13 métodos relacionados a associação:

* +_collection_(force_reload = false)+
* +_collection_<<(object, ...)+
* +_collection_.delete(object, ...)+
* +_collection_=objects+
* +_collection\_singular_\_ids+
* +_collection\_singular_\_ids=ids+
* +_collection_.clear+
* +_collection_.empty?+
* +_collection_.size+
* +_collection_.find(...)+
* +_collection_.exist?(...)+
* +_collection_.build(attributes = {}, ...)+
* +_collection_.create(attributes = {})+

Em todos estes métodos, +_collection_+ é substituído pelo símbolo passado como primeiro argumento da +has_many+, e +_collection\_singular_+ é substituído pela versão no singular deste símbolo. Por exemplo, veja abaixo:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

Cada instância do model customer terá os seguintes métodos:

[source, ruby]
-------------------------------------------------------
orders(force_reload = false)
orders<<(object, ...)
orders.delete(object, ...)
orders=objects
order_ids
order_ids=ids
orders.clear
orders.empty?
orders.size
orders.find(...)
orders.exist?(...)
orders.build(attributes = {}, ...)
orders.create(attributes = {})
-------------------------------------------------------

===== +_collection_(force_reload = false)+

O método +_collection_+ retorna um array com todos os objetos associados. Se não existir objeto associado, ele retorna um array vazio. 

[source, ruby]
-------------------------------------------------------
@orders = @customer.orders
-------------------------------------------------------

===== +_collection_<<(object, ...)+

O método +_collection_<<+ adiciona um ou mais objetos para a coleção, definindo suas chaves estrangeiras para a chave primária do model que o chamou.

[source, ruby]
-------------------------------------------------------
@customer.orders << @order1
-------------------------------------------------------

===== +_collection_.delete(object, ...)+

O método +_collection_.delete+ remove um ou mais objetos da coleção definindo suas chaves estrangeiras para +NULL+.

[source, ruby]
-------------------------------------------------------
@customer.orders.delete(@order1)
-------------------------------------------------------

WARNING: Os objetos associados serão destruídos, se existir +:dependent => :destroy+, e excluídos se estiverem associados com +:dependent => :delete_all+.

===== +_collection_=objects+

O método +_collection_=+ faz com que a coleção contenha apenas os objetos passados, adicionando ou removendo o que não interessa.

===== +_collection\_singular_\_ids+

O método +_collection\_singular_\_ids+ retorna um array com os ids dos objetos da coleção.

[source, ruby]
-------------------------------------------------------
@order_ids = @customer.order_ids
-------------------------------------------------------

===== +__collection\_singular_\_ids=ids+

O método +__collection\_singular_\_ids=+ faz com que a coleção contenha apenas os objetos identificados pela chave primária passada, adicionando e apagando o que não interessa.

===== +_collection_.clear+

O método +_collection_.clear+ remove todos os objetos da coleção. Isto destrói os objetos associados se estiverem associados com a opção +:dependent => :destroy+, ou apagando-os direto do banco de dados caso seja definido +:dependent => :delete_all+, caso contrário suas chaves estrangeiras serão definidas para +NULL+.

===== +_collection_.empty?+

O método +_collection_.empty?+ retorna +true+ se a coleção não contiver nenhum objeto associado.

[source, ruby]
-------------------------------------------------------
<% if @customer.orders.empty? %>
  No Orders Found
<% end %>
-------------------------------------------------------

===== +_collection_.size+


O método +_collection_.size+ retorna o número de objetos na coleção.

[source, ruby]
-------------------------------------------------------
@order_count = @customer.orders.size
-------------------------------------------------------

===== +_collection_.find(...)+


O método +_collection_.find+ encontra objetos na coleção. Ele utiliza a mesma sintaxe e opções do +ActiveRecord::Base.find+.

[source, ruby]
-------------------------------------------------------
@open_orders = @customer.orders.find(:all, :conditions => "open = 1")
-------------------------------------------------------

===== +_collection_.exist?(...)+


O método +_collection_.exist?+ verifica se existe o objeto associado que corresponda a condição passada como argumento. Ele utiliza a mesma sintaxe e opções do +ActiveRecord::Base.exists?+.

===== +_collection_.build(attributes = {}, ...)+


O método +_collection_.build+ retorna um ou mais novos objetos do tipo associado. Estes objetos são instanciados a partir dos atributos passados, e associados através da chave estrangeira que será criada, mas os objetos associados ainda _não_ serão salvos.

[source, ruby]
-------------------------------------------------------
@order = @customer.orders.build({:order_date => Time.now, :order_number => "A12345"})
-------------------------------------------------------

===== +_collection_.create(attributes = {})+

O método +_collection_.create+ retorna um novo objeto do tipo associado. Estes objetos são instanciados a partir dos atributos passados, e associados através da chave estrangeira que será criada, mas os objetos associados ainda _serão_ salvos (assumindo que passem nas validações).

[source, ruby]
-------------------------------------------------------
@order = @customer.orders.create({:order_date => Time.now, :order_number => "A12345"})
-------------------------------------------------------

==== Options for has_many

Em várias situações, você pode usar as opções padrão para o +has_many+ sem nenhuma customização. Mas você pode alterar este comportamento de várias maneiras. Esta seção cobre as opções que você pode passar quando cria uma associação +has_many+ . Por exemplo, uma associação com várias opção pode parecer como isto:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :dependent => :delete_all, :validate => :false
end
-------------------------------------------------------

Uma associação +has_many+ suporta estas opções:

// * +:accessible+
* +:as+
* +:class_name+
* +:conditions+
* +:counter_sql+
* +:dependent+
* +:extend+
* +:finder_sql+
* +:foreign_key+
* +:group+
* +:include+
* +:limit+
* +:offset+
* +:order+
* +:primary_key+
* +:readonly+
* +:select+
* +:source+
* +:source_type+
* +:through+
* +:uniq+
* +:validate+

// ===== +:accessible+
//
// The +:accessible+ option is the association version of +ActiveRecord::Base#attr_accessible+. If you set the +:accessible+ option to true, then mass // assignment is allowed for this association.
//
===== +:as+

Definindo a opção +:as+ indica que essa será uma associação polimórfica, como discutido previamente neste guia.

===== +:class_name+

Se o nome do outro model não puder ser descoberto pelo nome da associação, você pode usar +:class_name+ para prover o nome do model. Por exemplo, se um cliente (customer) possui muitos pedidos (orders), mas o nome atual do model que contém pedidos é +Transaction+, você vai definir as coisas desta forma:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :class_name => "Transaction"
end
-------------------------------------------------------

===== +:conditions+

A opção +:conditions+ permite que especifique as condições que a associação precisa atender ( na sintaxe usada por uma cláusula SQL +WHERE+).

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :confirmed_orders, :class_name => "Order", :conditions => "confirmed = 1"
end
-------------------------------------------------------

Você também pode passar condições como um hash:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :confirmed_orders, :class_name => "Order", :conditions => { :confirmed => true }
end
-------------------------------------------------------

Se você usa +:conditions+ no estilo hash, então a criação do registro através desta associação terá automaticamente o escopo usando o hash. Neste caso, usando  +@customer.confirmed_orders.create+ ou +@customer.confirmed_orders.build+ vai criar pedidos que tenham a coluna confirmed igual a +true+.

===== +:counter_sql+

Normalmente o Rails gera automaticamente o SQL apropriado para contar os membros de uma associação. Com a opção +:counter_sql+, você pode especificar o comando SQL para fazer o "count" da sua forma.

NOTE: Se você especificar +:finder_sql+ mas não definir +:counter_sql+, então o SQL para contador será gerado substituindo +SELECT COUNT(*) FROM+ para a cláusula +SELECT ... FROM+ da sua declaração do +:finder_sql+.

===== +:dependent+

Se você definir a opção +:dependent+ para +:destroy+, apagando este objeto irá chamar o método destroy de cada objeto associado para apagá-lo. Se você definir +:dependent+ para +:delete_all+, então apagar este objeto irá excluir os objetos associados _sem_ chamar o método +destroy+

NOTE: Esta opção é ignorada quando você utiliza a opção +:through+ na associação.

===== +:extend+

A opção +:extend+ especifica o nome de um módulo para extender a association proxy. Extensão de associações são discutidas mais a frente neste guia.

===== +:finder_sql+

Normalmente o Rails gera automaticamente o SQL apropriado para buscar os membros da associação. Com a opção +:finder_sql+, você pode especificar a cláusula SQL para busca-los. Se esta busca dos membros associados requer um SQL multi-table complexo, esta opção pode ser útil.

===== +:foreign_key+

Por convenção, Rails descobre que a coluna usada para armazenar a chave estrangeira em outro model é o nome deste model com o sufixo +_id+ adicionado. A opção +:foreign_key+ permite que você defina o nome da chave estrangeira diretamente.

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :foreign_key => "cust_id"
end
-------------------------------------------------------

TIP: Em nenhum caso, Rails vai gerar as colunas para a chave estrangeira automaticamente para você. Você precisa defini-las explicitamente em seus migrations.

===== +:group+

A opção +:group+ passa o nome de um atributo que será usado para agrupar o resultado, usando uma cláusula +GROUP BY+ no SQL.

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :line_items, :through => :orders, :group => "orders.id"
end
-------------------------------------------------------

===== +:include+

Você pode usar a opção :include para especificar associações de segunda ordem que devem ser carregadas previamente ( eager-loaded ) quando a associação for usada. Por exemplo, considere os models abaixo:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders
end
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
class LineItem < ActiveRecord::Base
  belongs_to :order
end
-------------------------------------------------------

Se você freqüentemente retorna line items diretamente de customers (+@customer.orders.line_items+), então você pode fazer seu código um pouco mais eficiente incluindo line item na associação de customers para orders:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :include => :line_items
end
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
class LineItem < ActiveRecord::Base
  belongs_to :order
end
-------------------------------------------------------

===== +:limit+

A opção +:limit+ permite que restringir o total de objetos que serão buscados através da associação.

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :recent_orders, :class_name => "Order", :order => "order_date DESC", :limit => 100
end
-------------------------------------------------------

===== +:offset+

A opção +:offset+ permite que você especifique de onde a busca dos objetos associados deve iniciar. Por exemplo, se você definir +:offset => 11+, irá ignorar os 10 primeiros registros.

===== +:order+

A opção +:order+ dita a ordem que cada objeto associado deve ser retornado ( gerando uma cláusula SQL +ORDER BY+).

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :order => "date_confirmed DESC"
end
-------------------------------------------------------

===== +:primary_key+

Por convenção, o Rails descobre que a coluna que armazenará a chave primária deste model é +id+. Você sobrescrever isso e especificar a chave primária com a opção +:primary_key+.

===== +:readonly+

Se você definir a opção +:readonly+ para +true+, os objetos associados serão somente leitura (read-only) quando forem retornados através da associação.

===== +:select+

A opção +:select+ permite que você sobrescreva a cláusula SQL +SELECT+ que será usada para retornar os objetos associados. Por padrão, Rails retorna todas as colunas.

WARNING: Se você especificar seu próprio +:select+, não se esqueça de incluir a chave primária e chave estrangeira do model associado. Se você não o fizer, Rails irás disparar um erro.

===== +:source+

A opção +:source+ especifica o nome de origem da associação para uma associação +has_many :through+. Você só precisa usar esta opção se o nome da associação não puder se inferida automaticamente a partir do nome da associação. 

===== +:source_type+

A opção +:source_type+ especifica o tipo da associação de origem para uma associação +has_many :through+ que proceda através de uma associação polimórfica.

===== +:through+

A opção +:through+ especifica um model para uma junção. Associações +has_many :through+ criam uma forma de implementar uma associação many-to-many (muitos para muitos), como discutido anteriormente neste guia.

===== +:uniq+

A opção +:uniq => true+ remove os registros duplicados de uma coleção retornada. É mais útil em conjunto com a opção +:through+.

===== +:validate+

Se você definir a opção +:validate+ para +false+, então os objetos associados não serão validados quando você salvar este objeto. Por padrão, este valor é +true+: objetos associados serão validados quando o objeto for salvo.

==== Quando os Objetos são Salvos?

Quando você atribui um objeto a uma associação +has_many+, este objeto é automaticamente salvo ( para atualizar sua chave estrangeira ). Se você atribuir múltiplos objetos em uma única declaração, então todos são salvos.

Se alguma dessas gravações falhar por error de validação, então a declaração de atribuição retornará +false+ e a atribuição será cancelada.

Se o objeto pai( o que estiver declarando a associação +has_many+) não é salvo ( ou seja, +new_record?+ retorna +true+) então os objetos filhos não são salvos quando são adicionados. Todos os membros não salvos de uma associação serão automaticamente salvos  quando o pai for salvo.

Se você quiser atribuir um objeto a uma associação +has_many+ sem salvar o objeto, use o método +_collection_.build+.

=== A Associação +has_and_belongs_to_many+

A associação +has_and_belongs_to_many+ cria um relacionamento muitos-para-muitos com outro model. Em termos de banco de dados, associa duas classes através de uma tabela intermediária que inclui as chaves estrangeiras de cada classe.

==== Métodos Adicionados

Quando você declara uma associação +has_and_belongs_to_many+, a classe que declara ganha 13 métodos relacionados a associação:

* +_collection_(force_reload = false)+
* +_collection_<<(object, ...)+
* +_collection_.delete(object, ...)+
* +_collection_=objects+
* +_collection\_singular_\_ids+
* +_collection\_singular_\_ids=ids+
* +_collection_.clear+
* +_collection_.empty?+
* +_collection_.size+
* +_collection_.find(...)+
* +_collection_.exist?(...)+
* +_collection_.build(attributes = {})+
* +_collection_.create(attributes = {})+

Em todos estes métodos, +_collection_+ é substituído pelo símbolo passado como primeiro argumento do +has_many+, e +_collection_\_singular+ é substituído pela versão no singular do símbolo. Por exemplo, a declaração abaixo:

[source, ruby]
-------------------------------------------------------
class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end
-------------------------------------------------------

Cada instância do model terá os seguintes métodos:

[source, ruby]
-------------------------------------------------------
assemblies(force_reload = false)
assemblies<<(object, ...)
assemblies.delete(object, ...)
assemblies=objects
assembly_ids
assembly_ids=ids
assemblies.clear
assemblies.empty?
assemblies.size
assemblies.find(...)
assemblies.exist?(...)
assemblies.build(attributes = {}, ...)
assemblies.create(attributes = {})
-------------------------------------------------------

===== Métodos Para Colunas Adicionais

Se a tabela auxiliar para a junção de uma associação +has_and_belongs_to_many+ possui alguma coluna além das duas chaves estrangeiras, estas colunas serão adicionadas como atributos no registros retornados pela associação. Registros retornados com atributos adicionais serão sempre somente-leitura(read-only), porque o Rails não pode salvar alterações nestes atributos.

WARNING: O uso de atributos extra em uma tabela de junção em uma associação +has_and_belongs_to_many+ foi deprecado. Se você precisa deste tipo de comportamento complexo em uma tabela que une dois models em uma relação many-to-many(muitos para muitos), você deve usar uma associação +has_many :through+ ao invés de +has_and_belongs_to_many+.

===== +_collection_(force_reload = false)+

O método +_collection_+ retorna um array com todos os objetos associados. Se não existir objetos associados, retorna um array vázio.

[source, ruby]
-------------------------------------------------------
@assemblies = @part.assemblies
-------------------------------------------------------

===== +_collection_<<(object, ...)+

O método +_collection_<<+ adiciona um ou mais objetos a uma coleção criando registros na tabela de junção.

[source, ruby]
-------------------------------------------------------
@part.assemblies << @assembly1
-------------------------------------------------------

NOTE: Este método é uma alias para +_collection_.concat+ e +_collection_.push+.

===== +_collection_.delete(object, ...)+

O método +_collection_.delete+ remove um ou mais objetos da coleção apagando registros da tabela de junção. Não destrói os objetos.

[source, ruby]
-------------------------------------------------------
@part.assemblies.delete(@assembly1)
-------------------------------------------------------

===== +_collection_=objects+

O método +_collection_=+ faz com que a coleção contenha apenas os objetos passados, adicionando e excluindo o que não interessa. 

===== +_collection\_singular_\_ids+

#   Returns an array of the associated objects' ids

O método +_collection\_singular_\_ids+ retorna um array com os ids dos objetos na coleção.

[source, ruby]
-------------------------------------------------------
@assembly_ids = @part.assembly_ids
-------------------------------------------------------

===== +_collection\_singular_\_ids=ids+

O método +_collection\_singular_\_ids=+ faz com que a coleção contenha apenas os objetos identificados pelas chaves primárias passadas, inserindo e excluindo o que não interessa.

===== +_collection_.clear+

O método +_collection_.clear+ remove cada objeto da coleção através da exclusão das linhas na tabela de junção. Isso não destrói os objetos associados.

===== +_collection_.empty?+

O método +_collection_.empty?+ retorna +true+ se a coleção não contém nenhum objeto associado.

[source, ruby]
-------------------------------------------------------
<% if @part.assemblies.empty? %>
  This part is not used in any assemblies
<% end %>
-------------------------------------------------------

===== +_collection_.size+

A método +_collection_.size+ retorna o número de objetos na coleção.

[source, ruby]
-------------------------------------------------------
@assembly_count = @part.assemblies.size
-------------------------------------------------------

===== +_collection_.find(...)+

O método +_collection_.find+ encontra os objetos dentro da coleção. Ele utiliza a mesma sintaxe e opções do +ActiveRecord::Base.find+. Acrescenta também a condição adicional de que o objeto deve estar na coleção.

[source, ruby]
-------------------------------------------------------
@new_assemblies = @part.assemblies.find(:all, :conditions => ["created_at > ?", 2.days.ago])
-------------------------------------------------------

===== +_collection_.exist?(...)+

O método +_collection_.exist?+ checa se algum objeto atende as condições na coleção. Utiliza a mesma sintaxe e opções do +ActiveRecord::Base.exists?+.

===== +_collection_.build(attributes = {})+

O método +_collection_.build+ retorna um novo objeto do tipo associado. Este objeto será instanciado a partir dos atributos passados, e uma associação será criada através da tabela de junção, mas o objeto associado ainda _não_ será salvo.

[source, ruby]
-------------------------------------------------------
@assembly = @part.assemblies.build({:assembly_name => "Transmission housing"})
-------------------------------------------------------

===== +_collection_.create(attributes = {})+

O método +_collection_.create+ retorna um novo objeto do tipo associado. Este objeto será instanciado a partir dos atributos passados, e uma associação será criada através da tabela de junção, e o objeto associado _será_ salvo (contando que atenda todas as validações).

[source, ruby]
-------------------------------------------------------
@assembly = @part.assemblies.create({:assembly_name => "Transmission housing"})
-------------------------------------------------------

==== Opções para has_and_belongs_to_many

Em muitas situações, você pode usar o comportamento padrão para +has_and_belongs_to_many+ sem nenhuma customização. Mas você pode alterar este comportamento de várias formas. Esta seção cobre as opções que você pode passar quando ao criar uma associação +has_and_belongs_to_many+. Por exemplo, uma associação com várias opções pode parecer com isso:

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :uniq => true, :read_only => true
end
-------------------------------------------------------

Associação +has_and_belongs_to_many+ suporta essas opções:

// * +:accessible+
* +:association_foreign_key+
* +:class_name+
* +:conditions+
* +:counter_sql+
* +:delete_sql+
* +:extend+
* +:finder_sql+
* +:foreign_key+
* +:group+
* +:include+
* +:insert_sql+
* +:join_table+
* +:limit+
* +:offset+
* +:order+
* +:readonly+
* +:select+
* +:uniq+
* +:validate+

// ===== +:accessible+
//
// The +:accessible+ option is the association version of +ActiveRecord::Base#attr_accessible+. If you set the +:accessible+ option to true, then mass // assignment is allowed for this association.
//
===== +:association_foreign_key+

Por convenção, o Rails descobre que a coluna na tabela de junção usada para armazenar as chaves estrangeiras apontando para outros modelos é o nome do modelo com o sufixo +_id+ . A opção +:association_foreign_key+ permite que você defina o nome da chave estrangeira diretamente:

TIP: As opções +:foreign_key+ e +:association_foreign_key+ são uteis quando você estiver definindo um relação muitos-para-muitos em uma auto-junção. Por exemplo:

[source, ruby]
-------------------------------------------------------
class User < ActiveRecord::Base
  has_and_belongs_to_many :friends, :class_name => "User",
    :foreign_key => "this_user_id", :association_foreign_key => "other_user_id"
end
-------------------------------------------------------

===== +:class_name+

Se o nome do outro model não pouder ser encontrado a partir do nome da associação, você pode usar a opção +:class_name+ para passar o nome do model. Por exemplo, se parts contém assemblies, mas o nome do model que contém os assemblies é +Gadget+, você deve fazer algo como abaixo:

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :class_name => "Gadget"
end
-------------------------------------------------------

===== +:conditions+

A opção +:conditions+ permiti especificar a condição que o objeto associado deve atender ( na sintaxe usada por uma cláusula SQL +WHERE+ ).

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :conditions => "factory = 'Seattle'"
end
-------------------------------------------------------

Você também pode definir condições através de um hash:

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :conditions => { :factory => 'Seattle' }
end
-------------------------------------------------------

Se você utilizar +:conditions+ no estilo hash, então a criação dos registros pela associação será automaticamente escopada usando o hash. Neste casa, usando +@parts.assemblies.create+ ou +@parts.assemblies.build+ irá criar registros onde a coluna de criação conterá o valor "Seattle".

===== +:counter_sql+

Normalmente o Rails gera automaticamente o SQL apropriado para contar os membros da associação. Com a opção +:counter_sql+, você pode especificar o SQL para fazer a contagem.

NOTE: Se você especificar +:finder_sql+ mas não +:counter_sql+, o SQL contador será gerado substituindo +SELECT COUNT(*) FROM+ para a cláusula +SELECT ... FROM+ para a declaração do seu +:finder_sql+.

===== +:delete_sql+

Normalmente Rails gera automaticamente o SQL apropriado para remover as ligações entre as classes associadas. Com a opção +:delete_sql+, você pode especificar uma cláusula SQL para excluir da sua forma.

===== +:extend+

A opção +:extend+ especifica um módulo para estender o proxy de associação. Extensão de associações serão discutidas com mais detalhes neste guia.

===== +:finder_sql+

Normalmente Rails gera automaticamente o SQL apropriado para buscar os membros da associação. Com a opção +:finder_sql+, você pode especificar sua própria cláusula SQL para buscar os registros. Se a busca dos objetos requer um SQL complexo em um hierarquia multi-table, então esta opção pode ser necessária.

===== +:foreign_key+

Por convenção, o Rails adivinha que a coluna na tabela de junção que será usada para armazenar a chave estrangeira será o nome do model mais o sufixo +_id+. A opção +:foreign_key+ permite que você especifique o nome da chave estrangeira diretamente:

[source, ruby]
-------------------------------------------------------
class User < ActiveRecord::Base
  has_and_belongs_to_many :friends, :class_name => "User",
    :foreign_key => "this_user_id", :association_foreign_key => "other_user_id"
end
-------------------------------------------------------

===== +:group+

A opção +:group+ informa o nome de um atributo que será usado para agrupar os resultados, usando uma cláusula +GROUP BY+ em um SQL.

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :group => "factory"
end
-------------------------------------------------------

===== +:include+

Você pode usar a opção :include para especificar uma associação de segunda ordem que deve ser previamente carregada quando a associação for utilizada.

===== +:insert_sql+

Normalmente o Rails gera automaticamente o SQL apropriado para criar a associação entre as classes. Com a opção +:insert_sql+, você pode especificar um comando SQL para inserir os registros da sua forma.

===== +:join_table+

Se o nome padrão da tabela de junção, baseada em ordem léxica, não é o que você deseja, então é possível usar a opção +:join_table+ para sobrescrever este comportamento.

===== +:limit+

A opção +:limit+ permite a você restringir o número total de objeto que serão buscados através da associação.

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :order => "created_at DESC", :limit => 50
end
-------------------------------------------------------

===== +:offset+

A opção +:offset+ permite que você especifique de onde a busca dos objetos associados deve iniciar. Por exemplo, se você definir +:offset => 11+, irá ignorar os 10 primeiros registros.

===== +:order+

A opção +:order+ dita a ordem que cada objeto associado deve ser retornado ( gerando uma cláusula SQL +ORDER BY+).

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :order => "assembly_name ASC"
end
-------------------------------------------------------

===== +:readonly+

Se você definir a opção +:readonly+ para +true+, os objetos associados serão somente leitura (read-only) quando forem retornados através da associação.

===== +:select+

A opção +:select+ permite que você sobrescreva a cláusula SQL +SELECT+ que será usada para retornar os objetos associados. Por padrão, Rails retorna todas as colunas.

===== +:uniq+

Especificar a opção +:uniq => true+ remove as duplicações da coleção.

===== +:validate+

Quando você define a opção +:validate+ para +false, os objetos associados não serão associados quando você salvo este objeto. Por padrão, esta opção recebe +true+: objetos associados também serão validados quando o objeto for salvo.

==== Quando os Objetos são Salvos?

Quando você atribuir um objeto a uma associação +has_and_belongs_to_many+, este objeto é automaticamente salvo( para poder atualizar a tabela de junção). Se você atribuir múltiplos objetos em uma declaração, então todos são salvos.

Se uma das gravações falhar durante o processo de validações, então a atribuição retornará +false+ e a atribuição em si, será cancelada.

Se o objeto pai( o que estiver declarando a associação +has_and_belongs_to_many+) não for salvo (ou seja, +new_record?+ retorna +true+) então os filhos também não serão salvos quando forem adicionados. Todos os membros não salvos na associação serão automaticamente salvos quando o pai for salvo.

Se você quiser atribuir um objeto a uma associação +has_and_belongs_to_many+ sem salvar o objeto, use o método +_collection_.build+.

=== Association Callbacks

Normalmente callbacks fazem para do ciclo de vida de objetos Active Record, permitindo que você trabalhe com estes objetos em vários pontos. Por exemplo, você pode usar o callback +:before_save+ para fazer com que algo aconteça antes do objeto ser salvo.

Callbacks de associação são similares a callbacks normais, mas eles são acionados por eventos no ciclo de vida da coleção. Existem quatro callbacks de associação disponíveis:

* +before_add+
* +after_add+
* +before_remove+
* +after_remove+

Você define callbacks de associação adicionando opções na declaração da associação. Por exemplo:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :before_add => :check_credit_limit

  def check_credit_limit(order)
    ...
  end
end
-------------------------------------------------------

Rails passa o objeto a ser adicionado ou removido para o callback.

Você pode empilhar callbacks em um único evento passando-os como array:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :before_add => [:check_credit_limit, :calculate_shipping_charges]

  def check_credit_limit(order)
    ...
  end

  def calculate_shipping_charges(order)
    ...
  end
end
-------------------------------------------------------

Se +before_add+ disparar uma exceção, o objeto não será adicionado a coleção. Similarmente, se o callback +before_remove+ disparar uma exceção, o objeto não será removido da coleção.

=== Extensões de Associação

Você não está limitado as funcionalidades que o Rails automaticamente constrói nos objetos de um association proxy. Você pode estender estes objetos através de módulos anônimos, adicionando novos finders, creators ou outros métodos. Por exemplo:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders do
    def find_by_order_prefix(order_number)
      find_by_region_id(order_number[0..2])
    end
  end
end
-------------------------------------------------------

Se você tiver uma extensão que deve ser compartilhada em várias associações, então você pode usar um módulo nomeado. Por exemplo:

[source, ruby]
-------------------------------------------------------
module FindRecentExtension
  def find_recent
    find(:all, :conditions => ["created_at > ?", 5.days.ago])
  end
end

class Customer < ActiveRecord::Base
  has_many :orders, :extend => FindRecentExtension
end

class Supplier < ActiveRecord::Base
  has_many :deliveries, :extend => FindRecentExtension
end
-------------------------------------------------------

Para incluir mais de um módulo de extensão em uma única associações, basta especificar um array de nomes:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :extend => [FindRecentExtension, FindActiveExtension]
end
-------------------------------------------------------

Extensões podem referenciar a própria association proxy através de três acessadores:

* +proxy_owner+ retorna o objeto que a associação faz parte.
* +proxy_reflection+ retorna o objeto de reflexão que descreve a associação.
* +proxy_target+ retorna o objeto associado para +belongs_to+ ou +has_one+, ou a coleção de objetos associados para +has_many+ ou +has_and_belongs_to_many+.

== Changelog ==

http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/11[Lighthouse ticket]

* September 28, 2008: Corrected +has_many :through+ diagram, added polymorphic diagram, some reorganization by link:../authors.html#mgunderloy[Mike Gunderloy] . First release version.
* September 22, 2008: Added diagrams, misc. cleanup by link:../authors.html#mgunderloy[Mike Gunderloy] (not yet approved for publication)
* September 14, 2008: initial version by link:../authors.html#mgunderloy[Mike Gunderloy] (not yet approved for publication)
