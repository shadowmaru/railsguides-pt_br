O Guia de Associações do Active Record
=====================================

Este guia aborda as características de associação do ActiveRecord. Ao fazer referência a este guia, você será capaz de:

* Declarar associações entre os Models do ActiveRecord.
* Compreender os diferentes tipos de associações do ActiveRecord.
* Utilizar os métodos adicionados aos seus modelos através das associações criadas.

== Associações, Por quê?

Por que precisamos de associações entre os modelos? Porque tornam mais fácil e mais simples operações comuns no código. Considere, por exemplo, uma simples aplicação Rails que inclui um modelo para os clientes e um modelo para as encomendas. Cada cliente pode ter muitas encomendas. Sem as associações, os modelos de declarações seriam mais ou menos assim:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
end

class Order < ActiveRecord::Base
end
-------------------------------------------------------

Agora, suponha se quisesse acrescentar uma nova encomenda de um cliente existente. Gostaríamos de fazer algo parecido com isto:

[source, ruby]
-------------------------------------------------------
@order = Order.create(:order_date => Time.now, :customer_id => @customer.id)
-------------------------------------------------------

Ou apagar um cliente, e garantindo que todas as suas ordens fossem excluídas também:

[source, ruby]
-------------------------------------------------------
@orders = Order.find_by_customer_id(@customer.id)
@orders.each do |order|
  order.destroy
end
@customer.destroy
-------------------------------------------------------

Com as associações do ActiveRecord, que podemos simplificar - e outras - operações por declarações dizendo que existe uma conexão entre os dois modelos. Veja abaixo o código revisado para a criação de clientes e encomendas:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders
end

class Order < ActiveRecord::Base
  belongs_to :customer
end
-------------------------------------------------------

Com essa mudança, criando uma nova ordem para um determinado cliente é mais fácil:

[source, ruby]
-------------------------------------------------------
@order = @customer.orders.create(:order_date => Time.now)
-------------------------------------------------------

Excluindo um cliente e todas as suas encomendas é _muito_ mais fácil:

[source, ruby]
-------------------------------------------------------
@customer.destroy
-------------------------------------------------------

Para saber mais sobre os diferentes tipos de associações, leia a próxima seção deste Guia. Seguido por alguns truques e dicas para trabalhar com as associações e, em seguida, por uma referência completa para os métodos e opções para as associações em Rails.

== Os tipos de associações

Em Rails, uma _associação_ é uma conexão entre os dois modelos do ActiveRecord. As associações são implementadas usando macro de chamadas, de modo que você pode adicionar funcionalidades nos seus modelos. Por exemplo, declarando que um modelo possui +belongs_to+ com outro, você instrui o Rails a manter as informações de Chave Primária entre instâncias dos dois modelos, e você também receberá um número métodos úteis adicionado ao seu modelo. Rails suporta seis tipos de associação:

* +belongs_to+
* +has_one+
* +has_many+
* +has_many :through+
* +has_one :through+
* +has_and_belongs_to_many+

No restante deste guia, você aprenderá a declarar e utilizar as diversas formas de associações. Mas, primeiro, uma introdução rápida a situações em que cada tipo de associação é adequado.

=== Associação +belongs_to+

Uma associação +belongs_to+ cria uma conexão um-para-um com outro modelo, de modo a que cada instância do modelo com a declaração _“pertence a”_ uma instancia de um outro modelo. Por exemplo, se sua aplicação incluir clientes e encomendas, e cada encomenda pode ser atribuído por exatamente um cliente, você declararia o modelo desta forma:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer
end
-------------------------------------------------------

image:images/belongs_to.png[belongs_to Association Diagram]

=== A Associação +has_one+

A associação +has_one+ também prevê a criação de uma conexão um-para-um com outro modelo, mas com uma semântica um pouco diferente (e conseqüências). Esta associação indica que cada instância de um modelo contém ou possui uma instancia de outro modelo. Por exemplo, se cada um fornecedor na sua aplicação possui somente uma conta, você iria declarar o modelo fornecedor como este:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account
end
-------------------------------------------------------

image:images/has_one.png[has_one Association Diagram]

=== A Associação +has_many+

Uma associação +has_many+ indica uma conexão um-para-muitos com outro modelo. Você irá encontrar muitas vezes esta associação do _“outro lado”_ de uma associação +belongs_to+. Esta associação indica que cada instância do modelo possui nenhuma ou mais instancias do outro modelo. Por exemplo, em uma aplicação contendo clientes e encomendas, o modelo cliente deve ser declarado como este:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

NOTE: O nome do outro modelo é pluralizado quando declarado uma associação +has_many+.

image:images/has_many.png[has_many Association Diagram]

=== A Associação +has_many :through+

Um associação +has_many :through+ é freqüentemente utilizado para criar um conexão muitos-para-muitos com outro modelo. Esta associação indica que a declaração do modelo possa ser compensada com zero ou mais instancias de outro modelo _“através de”_  um processo de um terceiro modelo. Por exemplo, considere uma prática médica onde pacientes podem marcar para ver médicos. As declarações relevantes da associação devem ser semelhantes a este:

[source, ruby]
-------------------------------------------------------
class Physician < ActiveRecord::Base
  has_many :appointments
  has_many :patients, :through => :appointments
end

class Appointment < ActiveRecord::Base
  belongs_to :physician
  belongs_to :patient
end

class Patient < ActiveRecord::Base
  has_many :appointments
  has_many :physicians, :through => :appointments
end
-------------------------------------------------------

image:images/has_many_through.png[has_many :through Association Diagram]

O associação +has_many :through+ é também útil para a criação de _“atalhos”_ através de associações +has_many+ aninhadas. Por exemplo, se um documento tem muitas seções, e uma seção possui muitos parágrafos, você pode algumas vezes pegar uma simples coleção de todos os parágrafos no documento. Você poderia declarar desta forma:

[source, ruby]
-------------------------------------------------------
class Document < ActiveRecord::Base
  has_many :sections
  has_many :paragraphs, :through => :sections
end

class Section < ActiveRecord::Base
  belongs_to :document
  has_many :paragraphs
end

class Paragraph < ActiveRecord::Base
  belongs_to :section
end
-------------------------------------------------------

=== A Associação +has_one: through+

Uma associação +has_one :through+ cria uma conexão de um-para-um com outro modelo. Esta associação indica que a declaração do modelo possa ser combinada com uma instancia de outro modelo _através_ de um terceiro modelo. Por exemplo, se cada fornecedor possui uma conta, e cada conta está associada a um histórico da conta, então o modelo cliente poderá ser declarado desta forma:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account
  has_one :account_history, :through => :account
end

class Account < ActiveRecord::Base
  belongs_to :supplier
  has_one :account_history
end

class AccountHistory < ActiveRecord::Base
  belongs_to :account
end
-------------------------------------------------------

image:images/has_one_through.png[has_one :through Association Diagram]

=== A Associação +has_and_belongs_to_many+

Uma associação +has_and_belongs_to_many+ cria uma conexão direta muitos-para-muitos com outro modelo, sem intervir no modelo. Por exemplo, se a sua aplicação incluir peças e conjuntos, onde cada conjunto inclui várias peças e que cada peça aparece em muitos conjuntos, você poderia declarar os modelos desta maneira:

[source, ruby]
-------------------------------------------------------
class Assembly < ActiveRecord::Base
  has_and_belongs_to_many :parts
end

class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end
-------------------------------------------------------

image:images/habtm.png[has_and_belongs_to_many Association Diagram]

=== Escolhendo Entre +belongs_to+ e +has_one+

Se você deseja criar uma relação 1×1 entre dois modelos, será necessário adicionar a um +belongs_to+ e ao outro +has_one+. Como você sabe quem é quem?

A distinção está no lugar onde você colocou a chave estrangeira (ele fica na tabela da classe que foi declarada a associação +belongs_to+), mas você deveria refletir um pouco mais sobre o real significado desses dados. O relacionamento +has_one+ fala alguma coisa para os seus - ou seja, algo que aponta de volta para você. Por exemplo, faz mais sentido dizer que um fornecedor possui uma conta do que uma conta que possui um fornecedor. Isso sugere que o relacionamento correto é algo como este:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account
end

class Account < ActiveRecord::Base
  belongs_to :supplier
end
-------------------------------------------------------

A migração correspondente se parece com isso:

[source, ruby]
-------------------------------------------------------
class CreateSuppliers < ActiveRecord::Migration
  def self.up
    create_table :suppliers do |t|
      t.string  :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.integer :supplier_id
      t.string  :account_number
      t.timestamps
    end
  end

  def self.down
    drop_table :accounts
    drop_table :suppliers
  end
end
-------------------------------------------------------

NOTE: Usando +t.integer :supplier_id+ faz a nomeação da chave estrangeira óbvia e implicitamente. Nas versões atuais do Rails, você pode abstrair a implementação deste detalhe usando +t.references :supplier+.

=== Escolhendo Entre +has_many :through+ e +has_and_belongs_to_many+

Rails oferece duas maneiras diferentes para declarar um relacionamento um-para-muitos entre modelos. A maneira mais simples é usar +has_and_belongs_to_many+, que permite que você faça a associação diretamente:

[source, ruby]
-------------------------------------------------------
class Assembly < ActiveRecord::Base
  has_and_belongs_to_many :parts
end

class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end
-------------------------------------------------------

A segunda forma de declarar o relacionamento muitos-para-muitos é usar +has_many :through+. Isto faz com que crie uma associação indiretamente, através de um join no modelo:

[source, ruby]
-------------------------------------------------------
class Assembly < ActiveRecord::Base
  has_many :manifests
  has_many :parts, :through => :manifests
end

class Manifest < ActiveRecord::Base
  belongs_to :assembly
  belongs_to :part
end

class Part < ActiveRecord::Base
  has_many :manifests
  has_many :assemblies, :through => :manifests
end
-------------------------------------------------------

A regra é simples, você deve criar um relacionamento +has_many :through+ se você precisa trabalhar com o relacionamento do modelo como uma entidade independente. Se você não precisa fazer nada com relacionamento do modelo, pode ser mais simples se criar um relacionamento +has_and_belongs_to_many+ (mas você precisa se lembrar se precisa criar joins nas tabelas).

Você deve usar +has_many :through+ se você precisar de validações, callbacks (chamadas), ou atributos extras no join do modelo.

=== Associações polimórficas

Um pouco mais avançado é o twist em _associações polimórficas_. Com associações Polimórficas, um modelo pode pertencer a mais de um modelo, em uma única associação. Por exemplo, imagine que você possa ter um modelo foto que pertence a um empregado ou ao modelo produto. Veja como isso poderia ser declarada:

[source, ruby]
-------------------------------------------------------
class Picture < ActiveRecord::Base
  belongs_to :imageable, :polymorphic => true
end

class Employee < ActiveRecord::Base
  has_many :pictures, :as => :imageable
end

class Product < ActiveRecord::Base
  has_many :pictures, :as => :imageable
end
-------------------------------------------------------

Você pode pensar em uma declaração +belongs_to+ polimórfica criando uma interface que pode ser usada por qualquer outro modelo. A partir de uma instância do modelo +Employee+, você pode recuperar uma coleção de fotos: +@employee.pictures+. Da mesma forma, você pode usar +@product.pictures+. Se você tem uma instancia do modelo Picture você pode pegar seu pai através +@picture.imageable+. Para que isto funcione, você necessita declarar tanto uma coluna chave estrangeira e uma coluna tipo no modelo declarado com uma interface polimórficas:

[source, ruby]
-------------------------------------------------------
class CreatePictures < ActiveRecord::Migration
  def self.up
    create_table :pictures do |t|
      t.string  :name
      t.integer :imageable_id
      t.string  :imageable_type
      t.timestamps
    end
  end

  def self.down
    drop_table :pictures
  end
end
-------------------------------------------------------

Esta migração pode ser simplificada utilizando o formulário +t.references+:

[source, ruby]
-------------------------------------------------------
class CreatePictures < ActiveRecord::Migration
  def self.up
    create_table :pictures do |t|
      t.string  :name
      t.references :imageable, :polymorphic => true
      t.timestamps
    end
  end

  def self.down
    drop_table :pictures
  end
end
-------------------------------------------------------

image:images/polymorphic.png[Polymorphic Association Diagram]

=== Self Joins

Na criação de um modelo de dados, às vezes você irá encontrar um modelo que deverá ter uma relação a si própria. Por exemplo, você pode armazenar todos os empregados em uma única base de dados, mas ser capaz de rastrear relacionamentos como gerentes e subordinados. Esta situação pode ser modelada com as associações com ele mesmo:

[source, ruby]
-------------------------------------------------------
class Employee < ActiveRecord::Base
  has_many :subordinates, :class_name => "User", :foreign_key => "manager_id"
  belongs_to :manager, :class_name => "User"
end
-------------------------------------------------------

Com essa configuração, você pode utilizar +@employee.subordinates+ e +@employee.manager+.

== Tips, Tricks, and Warnings

Here are a few things you should know to make efficient use of Active Record associations in your Rails applications:

* Controlling caching
* Avoiding name collisions
* Updating the schema
* Controlling association scope

=== Controlling Caching

All of the association methods are built around caching that keeps the result of the most recent query available for further operations. The cache is even shared across methods. For example:

[source, ruby]
-------------------------------------------------------
customer.orders                 # retrieves orders from the database
customer.orders.size            # uses the cached copy of orders
customer.orders.empty?          # uses the cached copy of orders
-------------------------------------------------------

But what if you want to reload the cache, because data might have been changed by some other part of the application? Just pass +true+ to the association call:

[source, ruby]
-------------------------------------------------------
customer.orders                 # retrieves orders from the database
customer.orders.size            # uses the cached copy of orders
customer.orders(true).empty?    # discards the cached copy of orders and goes back to the database
-------------------------------------------------------

=== Avoiding Name Collisions

You are not free to use just any name for your associations. Because creating an association adds a method with that name to the model, it is a bad idea to give an association a name that is already used for an instance method of +ActiveRecord::Base+. The association method would override the base method and break things. For instance, +attributes+ or +connection+ are bad names for associations.

=== Updating the Schema

Associations are extremely useful, but they are not magic. You are responsible for maintaining your database schema to match your associations. In practice, this means two things. First, you need to create foreign keys as appropriate:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer
end
-------------------------------------------------------

This declaration needs to be backed up by the proper foreign key declaration on the orders table:

[source, ruby]
-------------------------------------------------------
class CreateOrders < ActiveRecord::Migration
  def self.up
    create_table :orders do |t|
      t.order_date   :datetime
      t.order_number :string
      t.customer_id  :integer
    end
  end

  def self.down
    drop_table :orders
  end
end
-------------------------------------------------------

If you create an association some time after you build the underlying model, you need to remember to create an +add_column+ migration to provide the necessary foreign key.

Second, if you create a +has_and_belongs_to_many+ association, you need to explicitly create the joining table. Unless the name of the join table is explicitly specified by using the +:join_table+ option, Active Record create the name by using the lexical order of the class names. So a join between customer and order models will give the default join table name of "customers_orders" because "c" outranks "o" in lexical ordering.

WARNING: The precedence between model names is calculated using the +<+ operator for +String+. This means that if the strings are of different lengths, and the strings are equal when compared up to the shortest length, then the longer string is considered of higher lexical precedence than the shorter one. For example, one would expect the tables "paper_boxes" and "papers" to generate a join table name of "papers_paper_boxes" because of the length of the name "paper_boxes", but it in fact generates a join table name of "paper_boxes_papers".

Whatever the name, you must manually generate the join table with an appropriate migration. For example, consider these associations:

[source, ruby]
-------------------------------------------------------
class Assembly < ActiveRecord::Base
  has_and_belongs_to_many :parts
end

class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end
-------------------------------------------------------

These need to be backed up by a migration to create the +assemblies_parts+ table. This table should be created without a primary key:

[source, ruby]
-------------------------------------------------------
class CreateAssemblyPartJoinTable < ActiveRecord::Migration
  def self.up
    create_table :assemblies_parts, :id => false do |t|
      t.integer :assembly_id
      t.integer :part_id
    end
  end

  def self.down
    drop_table :assemblies_parts
  end
end
-------------------------------------------------------

=== Controlling Association Scope

By default, associations look for objects only within the current module's scope. This can be important when you declare Active Record models within a module. For example:

[source, ruby]
-------------------------------------------------------
module MyApplication
  module Business
    class Supplier < ActiveRecord::Base
       has_one :account
    end

    class Account < ActiveRecord::Base
       belongs_to :supplier
    end
  end
end
-------------------------------------------------------

This will work fine, because both the +Supplier+ and the +Account+ class are defined within the same scope. But this will not work, because +Supplier+ and +Account+ are defined in different scopes:

[source, ruby]
-------------------------------------------------------
module MyApplication
  module Business
    class Supplier < ActiveRecord::Base
       has_one :account
    end
  end

  module Billing
    class Account < ActiveRecord::Base
       belongs_to :supplier
    end
  end
end
-------------------------------------------------------

To associate a model with a model in a different scope, you must specify the complete class name in your association declaration:

[source, ruby]
-------------------------------------------------------
module MyApplication
  module Business
    class Supplier < ActiveRecord::Base
       has_one :account, :class_name => "MyApplication::Billing::Account"
    end
  end

  module Billing
    class Account < ActiveRecord::Base
       belongs_to :supplier, :class_name => "MyApplication::Business::Supplier"
    end
  end
end
-------------------------------------------------------

== Detailed Association Reference

The following sections give the details of each type of association, including the methods that they add and the options that you can use when declaring an association.

=== The +belongs_to+ Association

The +belongs_to+ association creates a one-to-one match with another model. In database terms, this association says that this class contains the foreign key. If the other class contains the foreign key, then you should use +has_one+ instead.

==== Methods Added by +belongs_to+

When you declare a +belongs_to+ assocation, the declaring class automatically gains five methods related to the association:

* +_association_(force_reload = false)+
* +_association_=(associate)+
* +_association_.nil?+
* +build___association__(attributes = {})+
* +create___association__(attributes = {})+

In all of these methods, +_association_+ is replaced with the symbol passed as the first argument to +belongs_to+. For example, given the declaration:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer
end
-------------------------------------------------------

Each instance of the order model will have these methods:

[source, ruby]
-------------------------------------------------------
customer
customer=
customer.nil?
build_customer
create_customer
-------------------------------------------------------

===== +_association_(force_reload = false)+

The +_association_+ method returns the associated object, if any. If no associated object is found, it returns +nil+.

[source, ruby]
-------------------------------------------------------
@customer = @order.customer
-------------------------------------------------------

If the associated object has already been retrieved from the database for this object, the cached version will be returned. To override this behavior (and force a database read), pass +true+ as the +force_reload+ argument.

===== +_association_=(associate)+

The +_association_=+ method assigns an associated object to this object. Behind the scenes, this means extracting the primary key from the associate object and setting this object's foreign key to the same value.

[source, ruby]
-------------------------------------------------------
@order.customer = @customer
-------------------------------------------------------

===== +_association_.nil?+

The +_association_.nil?+ method returns +true+ if there is no associated object.

[source, ruby]
-------------------------------------------------------
if @order.customer.nil?
  @msg = "No customer found for this order"
end
-------------------------------------------------------

===== +build___association__(attributes = {})+

The +build__\_association__+ method returns a new object of the associated type. This object will be instantiated from the passed attributes, and the link through this object's foreign key will be set, but the associated object will _not_ yet be saved.

[source, ruby]
-------------------------------------------------------
@customer = @order.build_customer({:customer_number => 123, :customer_name => "John Doe"})
-------------------------------------------------------

===== +create___association__(attributes = {})+

The +create__\_association__+ method returns a new object of the associated type. This object will be instantiated from the passed attributes, and the link through this object's foreign key will be set. In addition, the associated object _will_ be saved (assuming that it passes any validations).

[source, ruby]
-------------------------------------------------------
@customer = @order.create_customer({:customer_number => 123, :customer_name => "John Doe"})
-------------------------------------------------------

==== Options for +belongs_to+

In many situations, you can use the default behavior of +belongs_to+ without any customization. But despite Rails' emphasis of convention over customization, you can alter that behavior in a number of ways. This section covers the options that you can pass when you create a +belongs_to+ association. For example, an association with several options might look like this:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :counter_cache => true, :conditions => "active = 1"
end
-------------------------------------------------------

The +belongs_to+ association supports these options:

// * +:accessible+
* +:class_name+
* +:conditions+
* +:counter_cache+
* +:dependent+
* +:foreign_key+
* +:include+
* +:polymorphic+
* +:readonly+
* +:select+
* +:validate+

// ===== +:accessible+
//
// The +:accessible+ option is the association version of +ActiveRecord::Base#attr_accessible+. If you set the +:accessible+ option to true, then mass // assignment is allowed for this association.
//
===== +:class_name+

If the name of the other model cannot be derived from the association name, you can use the +:class_name+ option to supply the model name. For example, if an order belongs to a customer, but the actual name of the model containing customers is +Patron+, you'd set things up this way:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :class_name => "Patron"
end
-------------------------------------------------------

===== +:conditions+

The +:conditions+ option lets you specify the conditions that the associated object must meet (in the syntax used by a SQL +WHERE+ clause).

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :conditions => "active = 1"
end
-------------------------------------------------------

===== +:counter_cache+

The +:counter_cache+ option can be used to make finding the number of belonging objects more efficient. Consider these models:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer
end
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

With these declarations, asking for the value of +@customer.orders.size+ requires making a call to the database to perform a +COUNT(*)+ query. To avoid this call, you can add a counter cache to the _belonging_ model:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :counter_cache => true
end
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

With this declaration, Rails will keep the cache value up to date, and then return that value in response to the +.size+ method.

Although the +:counter_cache+ option is specified on the model that includes the +belongs_to+ declaration, the actual column must be added to the _associated_ model. In the case above, you would need to add a column named +orders_count+ to the +Customer+ model. You can override the default column name if you need to:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :counter_cache => :count_of_orders
end
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

Counter cache columns are added to the containing model's list of read-only attributes through +attr_readonly+.

===== +:dependent+

If you set the +:dependent+ option to +:destroy+, then deleting this object will call the destroy method on the associated object to delete that object. If you set the +:dependent+ option to +:delete+, then deleting this object will delete the associated object _without_ calling its +destroy+ method.

WARNING: You should not specify this option on a +belongs_to+ association that is connected with a +has_many+ association on the other class. Doing so can lead to orphaned records in your database.

===== +:foreign_key+

By convention, Rails guesses that the column used to hold the foreign key on this model is the name of the association with the suffix +_id+ added. The +:foreign_key+ option lets you set the name of the foreign key directly:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :class_name => "Patron", :foreign_key => "patron_id"
end
-------------------------------------------------------

TIP: In any case, Rails will not create foreign key columns for you. You need to explicitly define them as part of your migrations.

===== +:include+

You can use the :include option to specify second-order associations that should be eager-loaded when this association is used. For example, consider these models:

[source, ruby]
-------------------------------------------------------
class LineItem < ActiveRecord::Base
  belongs_to :order
end
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

If you frequently retrieve customers directly from line items (+@line_item.order.customer+), then you can make your code somewhat more efficient by including customers in the association from line items to orders:

[source, ruby]
-------------------------------------------------------
class LineItem < ActiveRecord::Base
  belongs_to :order, :include => :customer
end
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

NOTE: There's no need to use +:include+ for immediate associations - that is, if you have +Order belongs_to :customer+, then the customer is eager-loaded automatically when it's needed.

===== +:polymorphic+

Passing +true+ to the +:polymorphic+ option indicates that this is a polymorphic association. Polymorphic associations were discussed in detail earlier in this guide.

===== +:readonly+

If you set the +:readonly+ option to +true+, then the associated object will be read-only when retrieved via the association.

===== +:select+

The +:select+ option lets you override the SQL +SELECT+ clause that is used to retrieve data about the associated object. By default, Rails retrieves all columns.

TIP: If you set the +:select+ option on a +belongs_to+ association, you should also set the +foreign_key+ option to guarantee the correct results.

===== +:validate+

If you set the +:validate+ option to +true+, then associated objects will be validated whenever you save this object. By default, this is +false+: associated objects will not be validated when this object is saved.

==== When are Objects Saved?

Assigning an object to a +belongs_to+ association does _not_ automatically save the object. It does not save the associated object either.

=== The has_one Association

The +has_one+ association creates a one-to-one match with another model. In database terms, this association says that the other class contains the foreign key. If this class contains the foreign key, then you should use +belongs_to+ instead.

==== Methods Added by +has_one+

When you declare a +has_one+ association, the declaring class automatically gains five methods related to the association:

* +_association_(force_reload = false)+
* +_association_=(associate)+
* +_association_.nil?+
* +build___association__(attributes = {})+
* +create___association__(attributes = {})+

In all of these methods, +_association_+ is replaced with the symbol passed as the first argument to +has_one+. For example, given the declaration:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account
end
-------------------------------------------------------

Each instance of the +Supplier+ model will have these methods:

[source, ruby]
-------------------------------------------------------
account
account=
account.nil?
build_account
create_account
-------------------------------------------------------

===== +_association_(force_reload = false)+

The +_association_+ method returns the associated object, if any. If no associated object is found, it returns +nil+.

[source, ruby]
-------------------------------------------------------
@account = @supplier.account
-------------------------------------------------------

If the associated object has already been retrieved from the database for this object, the cached version will be returned. To override this behavior (and force a database read), pass +true+ as the +force_reload+ argument.

===== +_association_=(associate)+

The +_association_=+ method assigns an associated object to this object. Behind the scenes, this means extracting the primary key from this object and setting the associate object's foreign key to the same value.

[source, ruby]
-------------------------------------------------------
@suppler.account = @account
-------------------------------------------------------

===== +_association_.nil?+

The +_association_.nil?+ method returns +true+ if there is no associated object.

[source, ruby]
-------------------------------------------------------
if @supplier.account.nil?
  @msg = "No account found for this supplier"
end
-------------------------------------------------------

===== +build___association__(attributes = {})+

The +build__\_association__+ method returns a new object of the associated type. This object will be instantiated from the passed attributes, and the link through its foreign key will be set, but the associated object will _not_ yet be saved.

[source, ruby]
-------------------------------------------------------
@account = @supplier.build_account({:terms => "Net 30"})
-------------------------------------------------------

===== +create___association__(attributes = {})+

The +create__\_association__+ method returns a new object of the associated type. This object will be instantiated from the passed attributes, and the link through its foreign key will be set. In addition, the associated object _will_ be saved (assuming that it passes any validations).

[source, ruby]
-------------------------------------------------------
@account = @supplier.create_account({:terms => "Net 30"})
-------------------------------------------------------

==== Options for +has_one+

In many situations, you can use the default behavior of +has_one+ without any customization. But despite Rails' emphasis of convention over customization, you can alter that behavior in a number of ways. This section covers the options that you can pass when you create a +has_one+ association. For example, an association with several options might look like this:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account, :class_name => "Billing", :dependent => :nullify
end
-------------------------------------------------------

The +has_one+ association supports these options:

// * +:accessible+
* +:as+
* +:class_name+
* +:conditions+
* +:dependent+
* +:foreign_key+
* +:include+
* +:order+
* +:primary_key+
* +:readonly+
* +:select+
* +:source+
* +:source_type+
* +:through+
* +:validate+

// ===== +:accessible+
//
// The +:accessible+ option is the association version of +ActiveRecord::Base#attr_accessible+. If you set the +:accessible+ option to true, then mass // assignment is allowed for this association.
//
===== +:as+

Setting the +:as+ option indicates that this is a polymorphic association. Polymorphic associations are discussed in detail later in this guide.

===== +:class_name+

If the name of the other model cannot be derived from the association name, you can use the +:class_name+ option to supply the model name. For example, if a supplier has an account, but the actual name of the model containing accounts is Billing, you'd set things up this way:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account, :class_name => "Billing"
end
-------------------------------------------------------

===== +:conditions+

The +:conditions+ option lets you specify the conditions that the associated object must meet (in the syntax used by a SQL +WHERE+ clause).

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account, :conditions => "confirmed = 1"
end
-------------------------------------------------------

===== +:dependent+

If you set the +:dependent+ option to +:destroy+, then deleting this object will call the destroy method on the associated object to delete that object. If you set the +:dependent+ option to +:delete+, then deleting this object will delete the associated object _without_ calling its +destroy+ method. If you set the +:dependent+ option to +:nullify+, then deleting this object will set the foreign key in the association object to +NULL+.

===== +:foreign_key+

By convention, Rails guesses that the column used to hold the foreign key on the other model is the name of this model with the suffix +_id+ added. The +:foreign_key+ option lets you set the name of the foreign key directly:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account, :foreign_key => "supp_id"
end
-------------------------------------------------------

TIP: In any case, Rails will not create foreign key columns for you. You need to explicitly define them as part of your migrations.

===== +:include+

You can use the :include option to specify second-order associations that should be eager-loaded when this association is used. For example, consider these models:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account
end
class Account < ActiveRecord::Base
  belongs_to :supplier
  belongs_to :representative
end
class Representative < ActiveRecord::Base
  has_many :accounts
end
-------------------------------------------------------

If you frequently retrieve representatives directly from suppliers (+@supplier.account.representative+), then you can make your code somewhat more efficient by including representatives in the association from suppliers to accounts:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account, :include => :representative
end
class Account < ActiveRecord::Base
  belongs_to :supplier
  belongs_to :representative
end
class Representative < ActiveRecord::Base
  has_many :accounts
end
-------------------------------------------------------

===== +:order+

The +:order+ option dictates the order in which associated objects will be received (in the syntax used by a SQL +ORDER BY+ clause). Because a +has_one+ association will only retrieve a single associated object, this option should not be needed.

===== +:primary_key+

By convention, Rails guesses that the column used to hold the primary key of this model is +id+. You can override this and explicitly specify the primary key with the +:primary_key+ option.

===== +:readonly+

If you set the +:readonly+ option to +true+, then the associated object will be read-only when retrieved via the association.

===== +:select+

The +:select+ option lets you override the SQL +SELECT+ clause that is used to retrieve data about the associated object. By default, Rails retrieves all columns.

===== +:source+

The +:source+ option specifies the source association name for a +has_one :through+ association.

===== +:source_type+

The +:source_type+ option specifies the source association type for a +has_one :through+ association that proceeds through a polymorphic association.

===== +:through+

The +:through+ option specifies a join model through which to perform the query. +has_one :through+ associations are discussed in detail later in this guide.

===== +:validate+

If you set the +:validate+ option to +true+, then associated objects will be validated whenever you save this object. By default, this is +false+: associated objects will not be validated when this object is saved.

==== When are Objects Saved?

When you assign an object to a +has_one+ association, that object is automatically saved (in order to update its foreign key). In addition, any object being replaced is also automatically saved, because its foreign key will change too.

If either of these saves fails due to validation errors, then the assignment statement returns +false+ and the assignment itself is cancelled.

If the parent object (the one declaring the +has_one+ association) is unsaved (that is, +new_record?+ returns +true+) then the child objects are not saved.

If you want to assign an object to a +has_one+ association without saving the object, use the +association.build+ method.

=== The has_many Association

The +has_many+ association creates a one-to-many relationship with another model. In database terms, this association says that the other class will have a foreign key that refers to instances of this class.

==== Methods Added

When you declare a +has_many+ association, the declaring class automatically gains 13 methods related to the association:

* +_collection_(force_reload = false)+
* +_collection_<<(object, ...)+
* +_collection_.delete(object, ...)+
* +_collection_=objects+
* +_collection\_singular_\_ids+
* +_collection\_singular_\_ids=ids+
* +_collection_.clear+
* +_collection_.empty?+
* +_collection_.size+
* +_collection_.find(...)+
* +_collection_.exist?(...)+
* +_collection_.build(attributes = {}, ...)+
* +_collection_.create(attributes = {})+

In all of these methods, +_collection_+ is replaced with the symbol passed as the first argument to +has_many+, and +_collection\_singular_+ is replaced with the singularized version of that symbol.. For example, given the declaration:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

Each instance of the customer model will have these methods:

[source, ruby]
-------------------------------------------------------
orders(force_reload = false)
orders<<(object, ...)
orders.delete(object, ...)
orders=objects
order_ids
order_ids=ids
orders.clear
orders.empty?
orders.size
orders.find(...)
orders.exist?(...)
orders.build(attributes = {}, ...)
orders.create(attributes = {})
-------------------------------------------------------

===== +_collection_(force_reload = false)+

The +_collection_+ method returns an array of all of the associated objects. If there are no associated objects, it returns an empty array.

[source, ruby]
-------------------------------------------------------
@orders = @customer.orders
-------------------------------------------------------

===== +_collection_<<(object, ...)+

The +_collection_<<+ method adds one or more objects to the collection by setting their foreign keys to the primary key of the calling model.

[source, ruby]
-------------------------------------------------------
@customer.orders << @order1
-------------------------------------------------------

===== +_collection_.delete(object, ...)+

The +_collection_.delete+ method removes one or more objects from the collection by setting their foreign keys to +NULL+.

[source, ruby]
-------------------------------------------------------
@customer.orders.delete(@order1)
-------------------------------------------------------

WARNING: Objects will be in addition destroyed if they're associated with +:dependent => :destroy+, and deleted if they're associated with +:dependent => :delete_all+.


===== +_collection_=objects+

The +_collection_=+ method makes the collection contain only the supplied objects, by adding and deleting as appropriate.

===== +_collection\_singular_\_ids+

The +_collection\_singular_\_ids+ method returns an array of the ids of the objects in the collection.

[source, ruby]
-------------------------------------------------------
@order_ids = @customer.order_ids
-------------------------------------------------------

===== +__collection\_singular_\_ids=ids+

The +__collection\_singular_\_ids=+ method makes the collection contain only the objects identified by the supplied primary key values, by adding and deleting as appropriate.

===== +_collection_.clear+

The +_collection_.clear+ method removes every object from the collection. This destroys the associated objects if they are associated with +:dependent => :destroy+, deletes them directly from the database if +:dependent => :delete_all+, and otherwise sets their foreign keys to +NULL+.

===== +_collection_.empty?+

The +_collection_.empty?+ method returns +true+ if the collection does not contain any associated objects.

[source, ruby]
-------------------------------------------------------
<% if @customer.orders.empty? %>
  No Orders Found
<% end %>
-------------------------------------------------------

===== +_collection_.size+

The +_collection_.size+ method returns the number of objects in the collection.

[source, ruby]
-------------------------------------------------------
@order_count = @customer.orders.size
-------------------------------------------------------

===== +_collection_.find(...)+

The +_collection_.find+ method finds objects within the collection. It uses the same syntax and options as +ActiveRecord::Base.find+.

[source, ruby]
-------------------------------------------------------
@open_orders = @customer.orders.find(:all, :conditions => "open = 1")
-------------------------------------------------------

===== +_collection_.exist?(...)+

The +_collection_.exist?+ method checks whether an object meeting the supplied conditions exists in the collection. It uses the same syntax and options as +ActiveRecord::Base.exists?+.

===== +_collection_.build(attributes = {}, ...)+

The +_collection_.build+ method returns one or more new objects of the associated type. These objects will be instantiated from the passed attributes, and the link through their foreign key will be created, but the associated objects will _not_ yet be saved.

[source, ruby]
-------------------------------------------------------
@order = @customer.orders.build({:order_date => Time.now, :order_number => "A12345"})
-------------------------------------------------------

===== +_collection_.create(attributes = {})+

The +_collection_.create+ method returns a new object of the associated type. This object will be instantiated from the passed attributes, the link through its foreign key will be created, and the associated object _will_ be saved (assuming that it passes any validations).

[source, ruby]
-------------------------------------------------------
@order = @customer.orders.create({:order_date => Time.now, :order_number => "A12345"})
-------------------------------------------------------

==== Options for has_many

In many situations, you can use the default behavior for +has_many+ without any customization. But you can alter that behavior in a number of ways. This section covers the options that you can pass when you create a +has_many+ association. For example, an association with several options might look like this:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :dependent => :delete_all, :validate => :false
end
-------------------------------------------------------

The +has_many+ association supports these options:

// * +:accessible+
* +:as+
* +:class_name+
* +:conditions+
* +:counter_sql+
* +:dependent+
* +:extend+
* +:finder_sql+
* +:foreign_key+
* +:group+
* +:include+
* +:limit+
* +:offset+
* +:order+
* +:primary_key+
* +:readonly+
* +:select+
* +:source+
* +:source_type+
* +:through+
* +:uniq+
* +:validate+

// ===== +:accessible+
//
// The +:accessible+ option is the association version of +ActiveRecord::Base#attr_accessible+. If you set the +:accessible+ option to true, then mass // assignment is allowed for this association.
//
===== +:as+

Setting the +:as+ option indicates that this is a polymorphic association, as discussed earlier in this guide.

===== +:class_name+

If the name of the other model cannot be derived from the association name, you can use the +:class_name+ option to supply the model name. For example, if a customer has many orders, but the actual name of the model containing orders is +Transaction+, you'd set things up this way:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :class_name => "Transaction"
end
-------------------------------------------------------

===== +:conditions+

The +:conditions+ option lets you specify the conditions that the associated object must meet (in the syntax used by a SQL +WHERE+ clause).

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :confirmed_orders, :class_name => "Order", :conditions => "confirmed = 1"
end
-------------------------------------------------------

You can also set conditions via a hash:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :confirmed_orders, :class_name => "Order", :conditions => { :confirmed => true }
end
-------------------------------------------------------

If you use a hash-style +:conditions+ option, then record creation via this association will be automatically scoped using the hash. In this case, using +@customer.confirmed_orders.create+ or +@customer.confirmed_orders.build+ will create orders where the confirmed column has the value +true+.

===== +:counter_sql+

Normally Rails automatically generates the proper SQL to count the association members. With the +:counter_sql+ option, you can specify a complete SQL statement to count them yourself.

NOTE: If you specify +:finder_sql+ but not +:counter_sql+, then the counter SQL will be generated by substituting +SELECT COUNT(*) FROM+ for the +SELECT ... FROM+ clause of your +:finder_sql+ statement.

===== +:dependent+

If you set the +:dependent+ option to +:destroy+, then deleting this object will call the destroy method on the associated objects to delete those objects. If you set the +:dependent+ option to +:delete_all+, then deleting this object will delete the associated objects _without_ calling their +destroy+ method. If you set the +:dependent+ option to +:nullify+, then deleting this object will set the foreign key in the associated objects to +NULL+.

NOTE: This option is ignored when you use the +:through+ option on the association.

===== +:extend+

The +:extend+ option specifies a named module to extend the association proxy. Association extensions are discussed in detail later in this guide.

===== +:finder_sql+

Normally Rails automatically generates the proper SQL to fetch the association members. With the +:finder_sql+ option, you can specify a complete SQL statement to fetch them yourself. If fetching objects requires complex multi-table SQL, this may be necessary.

===== +:foreign_key+

By convention, Rails guesses that the column used to hold the foreign key on the other model is the name of this model with the suffix +_id+ added. The +:foreign_key+ option lets you set the name of the foreign key directly:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :foreign_key => "cust_id"
end
-------------------------------------------------------

TIP: In any case, Rails will not create foreign key columns for you. You need to explicitly define them as part of your migrations.

===== +:group+

The +:group+ option supplies an attribute name to group the result set by, using a +GROUP BY+ clause in the finder SQL.

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :line_items, :through => :orders, :group => "orders.id"
end
-------------------------------------------------------

===== +:include+

You can use the :include option to specify second-order associations that should be eager-loaded when this association is used. For example, consider these models:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders
end
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
class LineItem < ActiveRecord::Base
  belongs_to :order
end
-------------------------------------------------------

If you frequently retrieve line items directly from customers (+@customer.orders.line_items+), then you can make your code somewhat more efficient by including line items in the association from customers to orders:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :include => :line_items
end
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
class LineItem < ActiveRecord::Base
  belongs_to :order
end
-------------------------------------------------------

===== +:limit+

The +:limit+ option lets you restrict the total number of objects that will be fetched through an association.

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :recent_orders, :class_name => "Order", :order => "order_date DESC", :limit => 100
end
-------------------------------------------------------

===== +:offset+

The +:offset+ option lets you specify the starting offset for fetching objects via an association. For example, if you set +:offset => 11+, it will skip the first 10 records.

===== +:order+

The +:order+ option dictates the order in which associated objects will be received (in the syntax used by a SQL +ORDER BY+ clause).

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :order => "date_confirmed DESC"
end
-------------------------------------------------------

===== +:primary_key+

By convention, Rails guesses that the column used to hold the primary key of this model is +id+. You can override this and explicitly specify the primary key with the +:primary_key+ option.

===== +:readonly+

If you set the +:readonly+ option to +true+, then the associated objects will be read-only when retrieved via the association.

===== +:select+

The +:select+ option lets you override the SQL +SELECT+ clause that is used to retrieve data about the associated objects. By default, Rails retrieves all columns.

WARNING: If you specify your own +:select+, be sure to include the primary key and foreign key columns of the associated model. If you do not, Rails will throw an error.

===== +:source+

The +:source+ option specifies the source association name for a +has_many :through+ association. You only need to use this option if the name of the source association cannot be automatically inferred from the association name.

===== +:source_type+

The +:source_type+ option specifies the source association type for a +has_many :through+ association that proceeds through a polymorphic association.

===== +:through+

The +:through+ option specifies a join model through which to perform the query. +has_many :through+ associations provide a way to implement many-to-many relationships, as discussed earlier in this guide.

===== +:uniq+

Specify the +:uniq => true+ option to remove duplicates from the collection. This is most useful in conjunction with the +:through+ option.

===== +:validate+

If you set the +:validate+ option to +false+, then associated objects will not be validated whenever you save this object. By default, this is +true+: associated objects will be validated when this object is saved.

==== When are Objects Saved?

When you assign an object to a +has_many+ association, that object is automatically saved (in order to update its foreign key). If you assign multiple objects in one statement, then they are all saved.

If any of these saves fails due to validation errors, then the assignment statement returns +false+ and the assignment itself is cancelled.

If the parent object (the one declaring the +has_many+ association) is unsaved (that is, +new_record?+ returns +true+) then the child objects are not saved when they are added. All unsaved members of the association will automatically be saved when the parent is saved.

If you want to assign an object to a +has_many+ association without saving the object, use the +_collection_.build+ method.

=== The +has_and_belongs_to_many+ Association

The +has_and_belongs_to_many+ association creates a many-to-many relationship with another model. In database terms, this associates two classes via an intermediate join table that includes foreign keys referring to each of the classes.

==== Methods Added

When you declare a +has_and_belongs_to_many+ association, the declaring class automatically gains 13 methods related to the association:

* +_collection_(force_reload = false)+
* +_collection_<<(object, ...)+
* +_collection_.delete(object, ...)+
* +_collection_=objects+
* +_collection\_singular_\_ids+
* +_collection\_singular_\_ids=ids+
* +_collection_.clear+
* +_collection_.empty?+
* +_collection_.size+
* +_collection_.find(...)+
* +_collection_.exist?(...)+
* +_collection_.build(attributes = {})+
* +_collection_.create(attributes = {})+

In all of these methods, +_collection_+ is replaced with the symbol passed as the first argument to +has_many+, and +_collection_\_singular+ is replaced with the singularized version of that symbol.. For example, given the declaration:

[source, ruby]
-------------------------------------------------------
class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end
-------------------------------------------------------

Each instance of the part model will have these methods:

[source, ruby]
-------------------------------------------------------
assemblies(force_reload = false)
assemblies<<(object, ...)
assemblies.delete(object, ...)
assemblies=objects
assembly_ids
assembly_ids=ids
assemblies.clear
assemblies.empty?
assemblies.size
assemblies.find(...)
assemblies.exist?(...)
assemblies.build(attributes = {}, ...)
assemblies.create(attributes = {})
-------------------------------------------------------

===== Additional Column Methods

If the join table for a +has_and_belongs_to_many+ association has additional columns beyond the two foreign keys, these columns will be added as attributes to records retrieved via that association. Records returned with additional attributes will always be read-only, because Rails cannot save changes to those attributes.

WARNING: The use of extra attributes on the join table in a +has_and_belongs_to_many+ association is deprecated. If you require this sort of complex behavior on the table that joins two models in a many-to-many relationship, you should use a +has_many :through+ association instead of +has_and_belongs_to_many+.


===== +_collection_(force_reload = false)+

The +_collection_+ method returns an array of all of the associated objects. If there are no associated objects, it returns an empty array.

[source, ruby]
-------------------------------------------------------
@assemblies = @part.assemblies
-------------------------------------------------------

===== +_collection_<<(object, ...)+

The +_collection_<<+ method adds one or more objects to the collection by creating records in the join table.

[source, ruby]
-------------------------------------------------------
@part.assemblies << @assembly1
-------------------------------------------------------

NOTE: This method is aliased as +_collection_.concat+ and +_collection_.push+.

===== +_collection_.delete(object, ...)+

The +_collection_.delete+ method removes one or more objects from the collection by deleting records in the join table. This does not destroy the objects.

[source, ruby]
-------------------------------------------------------
@part.assemblies.delete(@assembly1)
-------------------------------------------------------

===== +_collection_=objects+

The +_collection_=+ method makes the collection contain only the supplied objects, by adding and deleting as appropriate.

===== +_collection\_singular_\_ids+

#   Returns an array of the associated objects' ids

The +_collection\_singular_\_ids+ method returns an array of the ids of the objects in the collection.

[source, ruby]
-------------------------------------------------------
@assembly_ids = @part.assembly_ids
-------------------------------------------------------

===== +_collection\_singular_\_ids=ids+

The +_collection\_singular_\_ids=+ method makes the collection contain only the objects identified by the supplied primary key values, by adding and deleting as appropriate.

===== +_collection_.clear+

The +_collection_.clear+ method removes every object from the collection by deleting the rows from the joining tableassociation. This does not destroy the associated objects.

===== +_collection_.empty?+

The +_collection_.empty?+ method returns +true+ if the collection does not contain any associated objects.

[source, ruby]
-------------------------------------------------------
<% if @part.assemblies.empty? %>
  This part is not used in any assemblies
<% end %>
-------------------------------------------------------

===== +_collection_.size+

The +_collection_.size+ method returns the number of objects in the collection.

[source, ruby]
-------------------------------------------------------
@assembly_count = @part.assemblies.size
-------------------------------------------------------

===== +_collection_.find(...)+

The +_collection_.find+ method finds objects within the collection. It uses the same syntax and options as +ActiveRecord::Base.find+. It also adds the additional condition that the object must be in the collection.

[source, ruby]
-------------------------------------------------------
@new_assemblies = @part.assemblies.find(:all, :conditions => ["created_at > ?", 2.days.ago])
-------------------------------------------------------

===== +_collection_.exist?(...)+

The +_collection_.exist?+ method checks whether an object meeting the supplied conditions exists in the collection. It uses the same syntax and options as +ActiveRecord::Base.exists?+.

===== +_collection_.build(attributes = {})+

The +_collection_.build+ method returns a new object of the associated type. This object will be instantiated from the passed attributes, and the link through the join table will be created, but the associated object will _not_ yet be saved.

[source, ruby]
-------------------------------------------------------
@assembly = @part.assemblies.build({:assembly_name => "Transmission housing"})
-------------------------------------------------------

===== +_collection_.create(attributes = {})+

The +_collection_.create+ method returns a new object of the associated type. This objects will be instantiated from the passed attributes, the link through the join table will be created, and the associated object _will_ be saved (assuming that it passes any validations).

[source, ruby]
-------------------------------------------------------
@assembly = @part.assemblies.create({:assembly_name => "Transmission housing"})
-------------------------------------------------------

==== Options for has_and_belongs_to_many

In many situations, you can use the default behavior for +has_and_belongs_to_many+ without any customization. But you can alter that behavior in a number of ways. This section cover the options that you can pass when you create a +has_and_belongs_to_many+ association. For example, an association with several options might look like this:

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :uniq => true, :read_only => true
end
-------------------------------------------------------

The +has_and_belongs_to_many+ association supports these options:

// * +:accessible+
* +:association_foreign_key+
* +:class_name+
* +:conditions+
* +:counter_sql+
* +:delete_sql+
* +:extend+
* +:finder_sql+
* +:foreign_key+
* +:group+
* +:include+
* +:insert_sql+
* +:join_table+
* +:limit+
* +:offset+
* +:order+
* +:readonly+
* +:select+
* +:uniq+
* +:validate+

// ===== +:accessible+
//
// The +:accessible+ option is the association version of +ActiveRecord::Base#attr_accessible+. If you set the +:accessible+ option to true, then mass // assignment is allowed for this association.
//
===== +:association_foreign_key+

By convention, Rails guesses that the column in the join table used to hold the foreign key pointing to the other model is the name of that model with the suffix +_id+ added. The +:association_foreign_key+ option lets you set the name of the foreign key directly:

TIP: The +:foreign_key+ and +:association_foreign_key+ options are useful when setting up a many-to-many self-join. For example:

[source, ruby]
-------------------------------------------------------
class User < ActiveRecord::Base
  has_and_belongs_to_many :friends, :class_name => "User",
    :foreign_key => "this_user_id", :association_foreign_key => "other_user_id"
end
-------------------------------------------------------

===== +:class_name+

If the name of the other model cannot be derived from the association name, you can use the +:class_name+ option to supply the model name. For example, if a part has many assemblies, but the actual name of the model containing assemblies is +Gadget+, you'd set things up this way:

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :class_name => "Gadget"
end
-------------------------------------------------------

===== +:conditions+

The +:conditions+ option lets you specify the conditions that the associated object must meet (in the syntax used by a SQL +WHERE+ clause).

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :conditions => "factory = 'Seattle'"
end
-------------------------------------------------------

You can also set conditions via a hash:

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :conditions => { :factory => 'Seattle' }
end
-------------------------------------------------------

If you use a hash-style +:conditions+ option, then record creation via this association will be automatically scoped using the hash. In this case, using +@parts.assemblies.create+ or +@parts.assemblies.build+ will create orders where the factory column has the value "Seattle".

===== +:counter_sql+

Normally Rails automatically generates the proper SQL to count the association members. With the +:counter_sql+ option, you can specify a complete SQL statement to count them yourself.

NOTE: If you specify +:finder_sql+ but not +:counter_sql+, then the counter SQL will be generated by substituting +SELECT COUNT(*) FROM+ for the +SELECT ... FROM+ clause of your +:finder_sql+ statement.

===== +:delete_sql+

Normally Rails automatically generates the proper SQL to remove links between the associated classes. With the +:delete_sql+ option, you can specify a complete SQL statement to delete them yourself.

===== +:extend+

The +:extend+ option specifies a named module to extend the association proxy. Association extensions are discussed in detail later in this guide.

===== +:finder_sql+

Normally Rails automatically generates the proper SQL to fetch the association members. With the +:finder_sql+ option, you can specify a complete SQL statement to fetch them yourself. If fetching objects requires complex multi-table SQL, this may be necessary.

===== +:foreign_key+

By convention, Rails guesses that the column in the join table used to hold the foreign key pointing to this model is the name of this model with the suffix +_id+ added. The +:foreign_key+ option lets you set the name of the foreign key directly:

[source, ruby]
-------------------------------------------------------
class User < ActiveRecord::Base
  has_and_belongs_to_many :friends, :class_name => "User",
    :foreign_key => "this_user_id", :association_foreign_key => "other_user_id"
end
-------------------------------------------------------

===== +:group+

The +:group+ option supplies an attribute name to group the result set by, using a +GROUP BY+ clause in the finder SQL.

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :group => "factory"
end
-------------------------------------------------------

===== +:include+

You can use the :include option to specify second-order associations that should be eager-loaded when this association is used.

===== +:insert_sql+

Normally Rails automatically generates the proper SQL to create links between the associated classes. With the +:insert_sql+ option, you can specify a complete SQL statement to insert them yourself.

===== +:join_table+

If the default name of the join table, based on lexical ordering, is not what you want, you can use the +:join_table+ option to override the default.

===== +:limit+

The +:limit+ option lets you restrict the total number of objects that will be fetched through an association.

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :order => "created_at DESC", :limit => 50
end
-------------------------------------------------------

===== +:offset+

The +:offset+ option lets you specify the starting offset for fetching objects via an association. For example, if you set +:offset => 11+, it will skip the first 10 records.

===== +:order+

The +:order+ option dictates the order in which associated objects will be received (in the syntax used by a SQL +ORDER BY+ clause).

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :order => "assembly_name ASC"
end
-------------------------------------------------------

===== +:readonly+

If you set the +:readonly+ option to +true+, then the associated objects will be read-only when retrieved via the association.

===== +:select+

The +:select+ option lets you override the SQL +SELECT+ clause that is used to retrieve data about the associated objects. By default, Rails retrieves all columns.

===== +:uniq+

Specify the +:uniq => true+ option to remove duplicates from the collection.

===== +:validate+

If you set the +:validate+ option to +false+, then associated objects will not be validated whenever you save this object. By default, this is +true+: associated objects will be validated when this object is saved.

==== When are Objects Saved?

When you assign an object to a +has_and_belongs_to_many+ association, that object is automatically saved (in order to update the join table). If you assign multiple objects in one statement, then they are all saved.

If any of these saves fails due to validation errors, then the assignment statement returns +false+ and the assignment itself is cancelled.

If the parent object (the one declaring the +has_and_belongs_to_many+ association) is unsaved (that is, +new_record?+ returns +true+) then the child objects are not saved when they are added. All unsaved members of the association will automatically be saved when the parent is saved.

If you want to assign an object to a +has_and_belongs_to_many+ association without saving the object, use the +_collection_.build+ method.

=== Association Callbacks

Normal callbacks hook into the lifecycle of Active Record objects, allowing you to work with those objects at various points. For example, you can use a +:before_save+ callback to cause something to happen just before an object is saved.

Association callbacks are similar to normal callbacks, but they are triggered by events in the lifecycle of a collection. There are four available association callbacks:

* +before_add+
* +after_add+
* +before_remove+
* +after_remove+

You define association callbacks by adding options to the association declaration. For example:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :before_add => :check_credit_limit

  def check_credit_limit(order)
    ...
  end
end
-------------------------------------------------------

Rails passes the object being added or removed to the callback.

You can stack callbacks on a single event by passing them as an array:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :before_add => [:check_credit_limit, :calculate_shipping_charges]

  def check_credit_limit(order)
    ...
  end

  def calculate_shipping_charges(order)
    ...
  end
end
-------------------------------------------------------

If a +before_add+ callback throws an exception, the object does not get added to the collection. Similarly, if a +before_remove+ callback throws an exception, the object does not get removed from the collection.

=== Association Extensions

You're not limited to the functionality that Rails automatically builds into association proxy objects. You can also extend these objects through anonymous modules, adding new finders, creators, or other methods. For example:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders do
    def find_by_order_prefix(order_number)
      find_by_region_id(order_number[0..2])
    end
  end
end
-------------------------------------------------------

If you have an extension that should be shared by many associations, you can use a named extension module. For example:

[source, ruby]
-------------------------------------------------------
module FindRecentExtension
  def find_recent
    find(:all, :conditions => ["created_at > ?", 5.days.ago])
  end
end

class Customer < ActiveRecord::Base
  has_many :orders, :extend => FindRecentExtension
end

class Supplier < ActiveRecord::Base
  has_many :deliveries, :extend => FindRecentExtension
end
-------------------------------------------------------

To include more than one extension module in a single association, specify an array of names:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :extend => [FindRecentExtension, FindActiveExtension]
end
-------------------------------------------------------

Extensions can refer to the internals of the association proxy using these three accessors:

* +proxy_owner+ returns the object that the association is a part of.
* +proxy_reflection+ returns the reflection object that describes the association.
* +proxy_target+ returns the associated object for +belongs_to+ or +has_one+, or the collection of associated objects for +has_many+ or +has_and_belongs_to_many+.

== Changelog ==

http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/11[Lighthouse ticket]

* September 28, 2008: Corrected +has_many :through+ diagram, added polymorphic diagram, some reorganization by link:../authors.html#mgunderloy[Mike Gunderloy] . First release version.
* September 22, 2008: Added diagrams, misc. cleanup by link:../authors.html#mgunderloy[Mike Gunderloy] (not yet approved for publication)
* September 14, 2008: initial version by link:../authors.html#mgunderloy[Mike Gunderloy] (not yet approved for publication)
