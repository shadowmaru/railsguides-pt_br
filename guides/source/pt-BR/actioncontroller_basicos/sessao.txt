== Sessão ==

Sua aplicação tem uma sessão para cada usuário onde você pode armazenar pequenas quantidades de dados que serão persistidos durante cada requisição. A sessão só fica disponível para o controller e a view e pode utilizar um de diferentes mecanismos de armazenamento:

 * CookieStore - Armazena tudo no cliente.
 * DRbStore - Armazena os dados dem um servidor DRb.
 * MemCacheStore - Armazena os dados em um memcache.
 * ActiveRecordStore - Armazena os dados em um banco de dados utilizando o Active Record.

Todos os métodos utilizam um cookie - isto é obrigatório e o Rails não permite que qualquer parte da sessão seja passada de outra forma (por exemplo, você não pode utilizar parâmetros de requisição para passar o ID de uma session) por questão de segurança (é mais fácil interceptar e modificar uma sessão quando o ID faz parte da URL).

A maioria utiliza um cookie para armazenar o ID da sessão, que é então utilizado para procurar os dados da sessão no servidor. O método padrão e recomendado, o CookieStore, não armazena dados da sessão no servidor, mas sim no próprio cookie. Os dados são assinados criptograficamente para torná-los a prova de alterações, mas eles não são criptografados, então qualquer um com acesso ao cookie pode ler seu conteúdo, mas não editá-lo (o Rails não irá aceitá-lo se ele tiver sido editado). Ele só pode armazenar cerca de 4kB de dados - bem menos do que os outros métodos - mas isto geralmente é o suficiente. O armazenamento de grandes quantidades de dados não é recomendado, não importa qual o método de armazenamento de sessão a sua aplicação utilize. Você deve evitar principalmente armazenar objetos complexos (qualquer coisa diferente de objetos Ruby básicos, sendo o exemplo mais comum uma instância de um model) na sessão, já que o servidor pode não conseguir recuperá-los entre requisições, o que resultará em um erro. O armazenamento CookieStore tem a vantagem de não requerir qualquer configuração antes de ser utilizado - o Rails irá gerar uma "chave secreta" que será utilizada para assinar o cookie quando você criar a aplicação.

Read more about session storage in the link:../security.html[Security Guide].

If you need a different session storage mechanism, you can change it in the `config/environment.rb` file:

[source, ruby]
------------------------------------------
# Set to one of [:active_record_store, :drb_store, :mem_cache_store, :cookie_store]
config.action_controller.session_store = :active_record_store
------------------------------------------

=== Disabling the Session ===

Sometimes you don't need a session. In this case, you can turn it off to avoid the unnecessary overhead. To do this, use the `session` class method in your controller:

[source, ruby]
------------------------------------------
class ApplicationController < ActionController::Base
  session :off
end
------------------------------------------

You can also turn the session on or off for a single controller:

[source, ruby]
------------------------------------------
# The session is turned off by default in ApplicationController, but we
# want to turn it on for log in/out.
class LoginsController < ActionController::Base
  session :on
end
------------------------------------------

Or even for specified actions:

[source, ruby]
------------------------------------------
class ProductsController < ActionController::Base
  session :on, :only => [:create, :update]
end
------------------------------------------

=== Accessing the Session ===

In your controller you can access the session through the `session` instance method.

NOTE: There are two `session` methods, the class and the instance method. The class method which is described above is used to turn the session on and off while the instance method described below is used to access session values.

Session values are stored using key/value pairs like a hash:

[source, ruby]
------------------------------------------
class ApplicationController < ActionController::Base

private

  # Finds the User with the ID stored in the session with the key :current_user_id
  # This is a common way to handle user login in a Rails application; logging in sets the
  # session value and logging out removes it.
  def current_user
    @_current_user ||= session[:current_user_id] && User.find(session[:current_user_id])
  end

end
------------------------------------------

To store something in the session, just assign it to the key like a hash:

[source, ruby]
------------------------------------------
class LoginsController < ApplicationController

  # "Create" a login, aka "log the user in"
  def create
    if user = User.authenticate(params[:username, params[:password])
      # Save the user ID in the session so it can be used in subsequent requests
      session[:current_user_id] = user.id
      redirect_to root_url
    end
  end

end
------------------------------------------

To remove something from the session, assign that key to be `nil`:

[source, ruby]
------------------------------------------
class LoginsController < ApplicationController

  # "Delete" a login, aka "log the user out"
  def destroy
    # Remove the user id from the session
    session[:current_user_id] = nil
    redirect_to root_url
  end

end
------------------------------------------

To reset the entire session, use `reset_session`.

=== The flash ===

The flash is a special part of the session which is cleared with each request. This means that values stored there will only be available in the next request, which is useful for storing error messages etc. It is accessed in much the same way as the session, like a hash. Let's use the act of logging out as an example. The controller can send a message which will be displayed to the user on the next request:

[source, ruby]
------------------------------------------
class LoginsController < ApplicationController

  def destroy
    session[:current_user_id] = nil
    flash[:notice] = "You have successfully logged out"
    redirect_to root_url
  end

end
------------------------------------------

The `destroy` action redirects to the application's `root_url`, where the message will be displayed. Note that it's entirely up to the next action to decide what, if anything, it will do with what the previous action put in the flash. It's conventional to display eventual errors or notices from the flash in the application's layout:

------------------------------------------
<html>
  <!-- <head/> -->
  <body>
    <% if flash[:notice] -%>
      <p class="notice"><%= flash[:notice] %></p>
    <% end -%>
    <% if flash[:error] -%>
      <p class="error"><%= flash[:error] %></p>
    <% end -%>
    <!-- more content -->
  </body>
</html>
------------------------------------------

This way, if an action sets an error or a notice message, the layout will display it automatically.

If you want a flash value to be carried over to another request, use the `keep` method:

[source, ruby]
------------------------------------------
class MainController < ApplicationController

  # Let's say this action corresponds to root_url, but you want all requests here to be redirected to
  # UsersController#index. If an action sets the flash and redirects here, the values would normally be
  # lost when another redirect happens, but you can use keep to make it persist for another request.
  def index
    flash.keep # Will persist all flash values. You can also use a key to keep only that value: flash.keep(:notice)
    redirect_to users_url
  end

end
------------------------------------------

==== +flash.now+ ====

By default, adding values to the flash will make them available to the next request, but sometimes you may want to access those values in the same request. For example, if the `create` action fails to save a resource and you render the `new` template directly, that's not going to result in a new request, but you may still want to display a message using the flash. To do this, you can use `flash.now` in the same way you use the normal `flash`:

[source, ruby]
------------------------------------------
class ClientsController < ApplicationController

  def create
    @client = Client.new(params[:client])
    if @client.save
      # ...
    else
      flash.now[:error] = "Could not save client"
      render :action => "new"
    end
  end

end
------------------------------------------
