Um Guia para Testar Aplicações Rails
=====================================

Este guia abrange os mecanismos internos oferecidos pelo Rails para testar a sua aplicação. Ao ler este guia, você será capaz de:

* Entender a terminologia de testes do Rails
* Escrever testes unitários, funcionais e de integração para a sua aplicação
* Identificar outros métodos de testes e plugins

Este guia não vai te ensinar a escrever uma aplicação Rails; ele parte do princípio de que você está familiarizado com o "jeito Rails" de se fazer as coisas:

== Por que escrever testes para a sua aplicação Rails? ==

 * Rails facilita muito este trabalho. Ele começa produzindo o código-base de teste em segundo plano enquanto você está criando os seus models e controllers.
 * Rodando os seus testes você é capaz de garantir que o seu código atende às funcionalidades desejadas mesmo depois de algumas importantes refatorações.
 * Eles também podem simular requests para que você teste as respostas da sua aplicação sem ter que fazer isso pelo seu browser.

== Introdução aos Testes ==

O suporte a testes está presente no Rails desde o seu início. Isso não foi algo do tipo "opa! vamos fazer o suporte a testes porque isso é novidade e legal".  Quase toda aplicação Rails interage muito com uma base de dados - e, como resultado, os seus testes também  precisarão de uma base de dados para interagir. Para escrever testes eficientes, você vai precisar entender como configurar e popular esta base com amostras de dados.

=== Os 3 Ambientes ===

Toda aplicação rails que você constrói tem 3 ambientes: um para produção, um para desenvolvimento e um para testes.

Um lugar em que você vai encontrar esta distinção é no arquivo +config/database.yml+. Este arquivo de configuração YAML tem 3 diferentes seções definindo 3 configurações únicas de bases de dados:

 * production (produção)
 * development (desenvolvimento)
 * test (testes)

Isto permite que você configure e interaja com os dados de testes sem qualquer perigo de que os seus testes alterem dados do seu ambiente de produção.

Por exemplo, suponha que você precise testar o seu novo +apague_este_usuario_e_tudo_associado_a_ele+ método. Você não gostaria de rodar isto num ambiente em que não faça diferença destruir ou não dados?

Quando você acaba destruindo a sua base de teste (e isto vai acontecer), você pode reconstruí-la do zero de acordo com as especificações definidas nela mesma. Você pode fazer isso rodando +rake db:test:prepare+.

=== Rails preparado para Testes desde o Início ===

O Rails cria uma pasta +test+ assim que você cria uma aplicação usando +rails _nome_do_projeto_+. Se você listar o conteúdo desta pasta você verá

[source,shell]
------------------------------------------------------
$ ls -F test/

fixtures/       functional/     integration/    test_helper.rb  unit/
------------------------------------------------------

A pasta +unit+ é encarregada de armazenar testes para os seus models, a pasta +functional+ armazena testes para os seus controllers e a pasta +integration+ deve guardar testes que envolvam interações entre seus controllers. Fixtures são uma forma de organizar os dados de teste; elas ficam na pasta +fixtures+. O arquivo +test_helper.rb+ guarda as configurações padrão para os seus testes.

=== Os Segredos das Fixtures ===

Para ter bons testes, você precisará configurar dados de testes. No Rails, isto pode ser feito definindo e ajustando fixtures.

==== O Que São Fixtures? ====

_Fixtures_ é um nome bonito para amostra de dados. Fixtures permitem que você configure a sua base de dados de teste com informações pré-definidas antes de rodar os seus testes. São independentes de banco de dados e assumem um dos dois formatos: *YAML* ou *CSV*. Neste guia nós vamos usar o *YAML*, que é o formato preferido.

Você encontrará fixtures no seu diretório +test/fixtures+. Quando você roda +script/generate model+ para criar um novo model, fixture stubs serão criados e colocados neste diretórico automaticamente.

==== YAML ====

Fixtures do tipo YAML são uma forma muito amigável de descrever as suas amostras de dados. Estes tipos de fixtures têm a extensão *.yml* (como em +users.yml+).

Aqui está um exemplo de um arquivo de fixture YAML:

[source,ruby]
---------------------------------------------
# vejam!  Eu sou um comentário YAML!
david:
 name: David Heinemeier Hansson
 birthday: 1979-10-15
 profession: Systems development

steve:
 name: Steve Ross Kellock
 birthday: 1974-09-27
 profession: guy with keyboard
---------------------------------------------

Cada fixture tem um nome seguido seguido por uma lista de pares chave/valor desejados. Registros são separados por um espaço em branco. Você pode colocar comentários em uma fixture digitando o caracter # na primeira coluna.

==== ERb Dando Uma Força ====

ERb permite que você introduza código ruby em templates. Tanto as fixtures de formato YAML como CSV são pré-processadas com ERb quando carregadas. Com isso, é possível utilizar Ruby para te ajudar a gerar dados para seus testes.

[source, ruby]
--------------------------------------------------------------
<% earth_size = 20 -%>
mercury:
  size: <%= earth_size / 50 %>
  brightest_on: <%= 113.days.ago.to_s(:db) %>

venus:
  size: <%= earth_size / 2 %>
  brightest_on: <%= 67.days.ago.to_s(:db) %>

mars:
  size: <%= earth_size - 69 %>
  brightest_on: <%= 13.days.from_now.to_s(:db) %>
--------------------------------------------------------------

Qualquer coisa escrita ente a tag

[source, ruby]
------------------------
<% %>
------------------------

é considerada código Ruby. Quando esta fixture é carregada, o atributo +size+ dos três registros vão ser setados para 20/50, 20/2 e 20-69, respectivamente. O atributo +brightest_on+ também será calculado e formatado pelo Rails para ser compatível com a sua base de dados.

==== Fixtures em Ação ====

Por padrão, o Rails carrega automaticamente todas as fixtures existentes na pasta 'test/fixtures' para seus testes unitários e funcionais. O carregamento envolve três passos:

 * Remoção de qualquer dado pré-existente na tabela correspondente à fixture
 * Carregamento dos dados da fixture na tabela
 * Cópia do dado da fixture para uma variável para o caso de você querer acessá-lo diretamente

==== Hashes Com Poderes Especiais ====

As fixtures são basicamente objetos Hash. Como mencionado no tópico #3 acima, é possível acessar o objeto hahs diretamente porque ele é automaticamente setado como uma variável local do caso de teste. Por exemplo:

[source, ruby]
--------------------------------------------------------------
# isso vai retornar a Hash para a fixture de nome david
users(:david)

# isso vai retornar a propriedade id do objeto david
users(:david).id
--------------------------------------------------------------

As fixtures também podem tomar a forma da sua classe original. Desta forma, você poderá acessar somente os métodos disponíveis para aquela classe.

[source, ruby]
--------------------------------------------------------------
# usando o método find, nós temos o david como um objeto do tipo User
david = users(:david).find

# e agora nós temos acesso somente aos métodos disponível na classe User
email(david.girlfriend.email, david.location_tonight)
--------------------------------------------------------------

== Teste Unitários para os seus Models ==

Em Rails, testes unitários é o que você escreve para testar os seus models.

Para este guia, nós vamos usar o recurso _scaffolding_ do Rails. Ele vai gerar o model, uma migration, controller e views para o novo recurso numa única operação. Ele também vai gerar uma suíte de testes completa seguindo as melhores práticas do Rails. Eu vou usar exemplos deste código gerado e vou complementando-o com exemplos adicionais quando necessário.

NOTE: Para mais informações a respeito do Rails _scaffolding_, consulte o link:../comecando_com_rails.html[Começando com Rails]

Quando você usa +script/generate scaffold+ para um recurso, dentre outras coisas, ele cria um teste stub na pasta +test/unit+:

-------------------------------------------------------
$ script/generate scaffold post title:string body:text
...
create  app/models/post.rb
create  test/unit/post_test.rb
create  test/fixtures/posts.yml
...
-------------------------------------------------------

The default test stub in +test/unit/post_test.rb+ looks like this:
O teste stub padrão em +test/unit/post_test.rb+ é algo do tipo:

[source,ruby]
--------------------------------------------------
require 'test_helper'

class PostTest < ActiveSupport::TestCase
  # Replace this with your real tests.
  def test_truth
    assert true
  end
end
--------------------------------------------------

Uma análise de cada linha deste arquivo vai te orientar em relação ao código de teste do Rails e à sua terminologia.

[source,ruby]
--------------------------------------------------
require 'test_helper'
--------------------------------------------------

O arquivo `test_helper.rb` especifica a configuração padrão para rodar nossos testes. Isto é incluído em todos os testes, então todos os métodos existentes neste arquivo estão disponíveis para todos os seus testes.

[source,ruby]
--------------------------------------------------
class PostTest < ActiveSupport::TestCase
--------------------------------------------------

A classe +PostTest+ define um _test case_ (caso de teste) porque ela herda de +ActiveSupport::TestCase+. +PostTest+ tem, portanto, todos os métodos disponíveis em +ActiveSupport::TestCase+. Nós vamos estudar estes métodos um pouco mais a frente neste guia.

[source,ruby]
--------------------------------------------------
def test_truth
--------------------------------------------------

Qualquer método definido em um test case que começa com +test+ (case sensitive) é considerado um teste. +test_password+, +test_valid_password+ e +testValidPassword+ são nomes de testes válidos e são rodados automaticamente quando o test case é executado.

[source,ruby]
--------------------------------------------------
assert true
--------------------------------------------------

Esta linha de código é chamada de _assertion_. Uma assertion é uma linha de código que avalia um objeto (ou uma expressão) e espera alguns resultados. Por exemplo, uma assertion pode validar coisas do tipo:

* este valor é = a outro valor?  
* este objeto é nulo?  
* esta linha de código lança uma exceção?
* a senha do usuário tem mais do que 5 caracteres? 

Cada teste tem uma ou mais assertions. Somente quando todas as assertions são válidas o teste passa.

=== Preparando a sua Aplicação para ser Testada ===

Antes de poder rodar os testes, você precisa se certificar de que a estrutura da sua base de testes está atualizada. Para isso, você pode usar os seguintes comandos rake:

[source, shell]
-------------------------------------------------------
$ rake db:migrate
...
$ rake db:test:load
-------------------------------------------------------

+rake db:migrate+ todas as migrations que estiverem pendentes no ambiente _developemnt_ (ambiente de desenvolvimento) e atualiza o seu +db/schema.rb+. +rake db:test:load+ recria a base de testes a partir do db/schema.rb atual. Nas próximas vezes, é bom rodar primeiro +db:test:prepare+ para primeiramente verificar se há migrations pendentes e ver eventuais alertas apropriadamente.

NOTE: +db:test:prepare+ irá falhar se o arquivo db/schema.rb não existir.

==== Preparando a Aplicação para Testes com Tasks Rake ==

[grid="all"]
--------------------------------`-----------------------------------------------------------------
Tasks                           Descrição
--------------------------------------------------------------------------------------------------
+rake db:test:clone+            Recria a base de teste a partir do schema atual do banco de dados
+rake db:test:clone_structure+  Recria as bases de teste a partir da estrutura de desenvolvimento
+rake db:test:load+             Recria a base de teste a partir do +schema.rb+ atual
+rake db:test:prepare+          Verifica se há migrations pendentes e carrega o schema de teste
+rake db:test:purge+            Limpa o banco de dados de teste.
--------------------------------------------------------------------------------------------------

TIP: Você pode consultar todas estas tasks rake e suas descrições rodando +rake --tasks --describe+

=== Rodando os Testes ===

Para rodar um teste basta invocar o arquivo contendo os testes pelo Ruby:

[source, shell]
-------------------------------------------------------
$ cd test
$ ruby unit/post_test.rb 

Loaded suite unit/post_test
Started
.
Finished in 0.023513 seconds.

1 tests, 1 assertions, 0 failures, 0 errors
-------------------------------------------------------

Isto vai rodar todos os métodos de teste do arquivo.

Você também pode rodar um método de teste em particular usando a opção +-n+ com o +nome do método de teste+.

-------------------------------------------------------
$ ruby unit/post_test.rb -n test_truth

Loaded suite unit/post_test
Started
.
Finished in 0.023513 seconds.

1 tests, 1 assertions, 0 failures, 0 errors
-------------------------------------------------------

O +.+ (ponto) acima indica um teste que passou. Quando um teste falhar, você verá um +F+; quando um teste lançar um erro, você verá um +E+ no seu lugar. A última linha da saída é o sumário.

Para ver com um teste falho é reportado, você pode adicionar um teste falhando ao teste +post_test.rb+.

[source,ruby]
--------------------------------------------------
def test_should_not_save_post_without_title
  post = Post.new
  assert !post.save
end
--------------------------------------------------

Vamos rodar este novo teste.

-------------------------------------------------------
$ ruby unit/post_test.rb -n test_should_not_save_post_without_title
Loaded suite unit/post_test
Started
F
Finished in 0.197094 seconds.

  1) Failure:
test_should_not_save_post_without_title(PostTest)
    [unit/post_test.rb:11:in `test_should_not_save_post_without_title'
     /opt/local/lib/ruby/gems/1.8/gems/activesupport-2.1.1/lib/active_support/testing/setup_and_teardown.rb:33:in `__send__'
     /opt/local/lib/ruby/gems/1.8/gems/activesupport-2.1.1/lib/active_support/testing/setup_and_teardown.rb:33:in `run']:
<false> is not true.

1 tests, 1 assertions, 1 failures, 0 errors
-------------------------------------------------------

O +F+ na saída indica uma falha. Você pode ver o trace abaixo do +1)+ com o nome do teste que falhou. As próximas linhas contém o stack trace seguido por uma mensagem que indica o valor real (aquele produzido pelo seu programa) e o valor esperado pela assertion. As mensagens padrão da assertion nos dá somente a informação necessária para localizar o erro. Para tornar a mensagem de falha mais legível, toda assertion tem um parâmetro de mensagem opcional, como mostrado aqui:

[source,ruby]
--------------------------------------------------
def test_should_not_save_post_without_title
  post = Post.new
  assert !post.save, "Post salvo sem um título"
end
--------------------------------------------------

Ao rodar este teste, é exibida uma mensagem mais amigável:

-------------------------------------------------------
$ ruby unit/post_test.rb -n test_should_not_save_post_without_title
Loaded suite unit/post_test
Started
F
Finished in 0.198093 seconds.

  1) Failure:
test_should_not_save_post_without_title(PostTest)
    [unit/post_test.rb:11:in `test_should_not_save_post_without_title'
     /opt/local/lib/ruby/gems/1.8/gems/activesupport-2.1.1/lib/active_support/testing/setup_and_teardown.rb:33:in `__send__'
     /opt/local/lib/ruby/gems/1.8/gems/activesupport-2.1.1/lib/active_support/testing/setup_and_teardown.rb:33:in `run']:
Post salvo sem um título.
<false> is not true.

1 tests, 1 assertions, 1 failures, 0 errors
-------------------------------------------------------

Agora para fazer com que este teste passe, nós podemos adicionar uma validação no model para o campo _title_

[source,ruby]
--------------------------------------------------
class Post < ActiveRecord::Base
  validates_presence_of :title
end
--------------------------------------------------

Agora o teste deve passar. Vamos verificar rodando novamente:

-------------------------------------------------------
$ ruby unit/post_test.rb -n test_should_not_save_post_without_title
Loaded suite unit/post_test
Started
.
Finished in 0.193608 seconds.

1 tests, 1 assertions, 0 failures, 0 errors
-------------------------------------------------------

Se você reparar, primeiramente nós escrevemos um teste que falharia para uma funcionalidade desejada, então nós escrevemos um código que adiciona a funcionalidade e, finalmente, garantimos que nosso teste passaria. Este modo de desenvolver software é conhecido como _Test-Driven Development_ (TDD).

TIP: Muitos desenvolvedores Rails praticam _Test-Driven Development_ (TDD). Este é um modo excelente de construir uma suíte de testes que exercita todas as partes da sua aplicação. TDD foge do escopo deste guia, mas um lugar para se começar é com link:http://andrzejonsoftware.blogspot.com/2007/05/15-tdd-steps-to-create-rails.html[15 TDD steps to create a Rails application].

Para ver como um erro é reportado, aqui está um teste contendo um:

[source,ruby]
--------------------------------------------------
def test_should_report_error
  # some_undefined_variable is not defined elsewhere in the test case
  some_undefined_variable
  assert true
end
--------------------------------------------------

Agora você pode ver muito mais informações no console ao rodar os testes:

-------------------------------------------------------
$ ruby unit/post_test.rb -n test_should_report_error
Loaded suite unit/post_test
Started
E
Finished in 0.195757 seconds.

  1) Error:
test_should_report_error(PostTest):
NameError: undefined local variable or method `some_undefined_variable' for #<PostTest:0x2cc9de8>
    /opt/local/lib/ruby/gems/1.8/gems/actionpack-2.1.1/lib/action_controller/test_process.rb:467:in `method_missing'
    unit/post_test.rb:16:in `test_should_report_error'
    /opt/local/lib/ruby/gems/1.8/gems/activesupport-2.1.1/lib/active_support/testing/setup_and_teardown.rb:33:in `__send__'
    /opt/local/lib/ruby/gems/1.8/gems/activesupport-2.1.1/lib/active_support/testing/setup_and_teardown.rb:33:in `run'

1 tests, 0 assertions, 0 failures, 1 errors
-------------------------------------------------------

Repare no 'E' da saída. Ele indica um teste com erro.

NOTE: A execução de cada teste é interrompida assim que qualquer erro ou falha nas assertions seja encontrado, e a suíte de testes continua sendo executada no próximo método. Todos os testes são executados em ordem alfabética.

=== O Que Incluir Nos Seus Testes Unitários ===

Idealmente, você deveria escrever testes para tudo que possa falhar na sua aplicação. É uma boa prática ter pelo menos um teste para cada validação e ao menos um teste para cada método no seu model.

=== Assertions Disponíveis ===

Até agora, você teve somente uma idéia de algumas assertions disponíveis. Assertions são as 'formiguinhas' dos testes. Elas são quem realmente realizam as checagens e garantem que as coisas estão correndo como o planejado.

Há muitos tipos de assertions diferentes que você pode usar. Aqui está uma listagem completa das assertions existentes na +test/unit+, a biblioteca de testes usada pelo Rails. O parâmetro +[msg]+ é uma mensagem de texto opcional que você pode usar para que as mensagens de falha dos testes sejam mais claras. Não é um parâmetro obrigatório.

[grid="all"]
`-----------------------------------------------------------------`------------------------------------------------------------------------
Assertion                                                         Objetivo
------------------------------------------------------------------------------------------------------------------------------------------
+assert( boolean, [msg] )+                                        Garante que o objeto/expressão é true.
+assert_equal( obj1, obj2, [msg] )+                               Garante que +obj1 == obj2+ é true.
+assert_not_equal( obj1, obj2, [msg] )+                           Garante que +obj1 == obj2+ é false.
+assert_same( obj1, obj2, [msg] )+			                      Garante que +obj1.equal?(obj2)+ é true.
+assert_not_same( obj1, obj2, [msg] )+                            Garante que +obj1.equal?(obj2)+ é false.
+assert_nil( obj, [msg] )+                                        Garante que +obj.nil?+ é true.
+assert_not_nil( obj, [msg] )+                                    Garante que +obj.nil?+ é false.
+assert_match( regexp, string, [msg] )+                           Garante que a string atende à expressão regular.
+assert_no_match( regexp, string, [msg] )+                        Garante que a string não atende à expressão regular.
+assert_in_delta( expecting, actual, delta, [msg] )+              Garante que os números `expecting` e `actual` estão dentro do `delta`.
+assert_throws( symbol, [msg] ) { block }+                        Garante que o bloco lança o símbolo.
+assert_raises( exception1, exception2, ... ) { block }+          Garante que o bloco cria uma das exceções.
+assert_nothing_raised( exception1, exception2, ... ) { block }+  Garante que o bloco não cria nenhuma das exceções.
+assert_instance_of( class, obj, [msg] )+                         Garante que +obj+ é do mesmo tipo de +class+.
+assert_kind_of( class, obj, [msg] )+                             Garante que +obj+ é ou estende de +class+.
+assert_respond_to( obj, symbol, [msg] )+                         Garante que +obj+ tem um método chamado +symbol+.
+assert_operator( obj1, operator, obj2, [msg] )+                  Garante que +obj1.operator(obj2)+ é true.
+assert_send( array, [msg] )+                                     Garante que executar o método listado em +array[1]+ no objeto +array[0]+ com os parâmetros de +array[2 e acima]+ é true. Esta é estranha, não é?
+flunk( [msg] )+                                                  Ensures falha. É útil para marcar um teste que ainda não está terminado.
------------------------------------------------------------------------------------------------------------------------------------------

Por conta da natureza modular do framework de teste, é possível criar as suas próprias assertions. De fato, é exatamente o que o Rails faz. Ele inclui umas assertions especializadas para facilitar o seu trabalho.

NOTE: Criar as suas próprias assertions é um tópico avanado que nós não vamos cobrir neste tutorial.

=== Assertions Específicas do Rails ===

Rails adiciona algumas assertions ao framework +test/unit+:

[grid="all"]
`----------------------------------------------------------------------------------`-------------------------------------------------------
Assertion                                                                          Objetivo
------------------------------------------------------------------------------------------------------------------------------------------
+assert_valid(record)+                                                             Garante que o registro passado é valido segundo os padrões do Active Record e retorna mensagens de erro caso não seja.
+assert_difference(expressions, difference = 1, message = nil) {|| ...}+           Testa a diferença numérica entre o valor de retorno de uma expressão com o resultado do que produzido pela execução do bloco.
+assert_no_difference(expressions, message = nil, &block)+                         Asserta que o resultado numérico da execução de uma expressão não é alterado antes e depois da invocação do bloco   Asserts that the numeric result of evaluating an expression is not changed before and after invoking the passed in block.
+assert_recognizes(expected_options, path, extras={}, message=nil)+                 Asserts that the routing of the given path was handled correctly and that the parsed options (given in the expected_options hash) match path. Basically, it asserts that Rails recognizes the route given by expected_options.
+assert_generates(expected_path, options, defaults={}, extras = {}, message=nil)+   Asserts that the provided options can be used to generate the provided path. This is the inverse of assert_recognizes. The extras parameter is used to tell the request the names and values of additional request parameters that would be in a query string. The message parameter allows you to specify a custom error message for assertion failures.
+assert_response(type, message = nil)+                                              Asserts that the response comes with a specific status code. You can specify +:success+ to indicate 200,  +:redirect+ to indicate 300-399, +:missing+ to indicate 404, or +:error+ to match the 500-599 range
+assert_redirected_to(options = {}, message=nil)+                                   Assert that the redirection options passed in match those of the redirect called in the latest action. This match can be partial, such that +assert_redirected_to(:controller => "weblog")+ will also match the redirection of +redirect_to(:controller => "weblog", :action => "show")+ and so on.
+assert_template(expected = nil, message=nil)+                                      Asserts that the request was rendered with the appropriate template file.
------------------------------------------------------------------------------------------------------------------------------------------

You'll see the usage of some of these assertions in the next chapter.

== Functional Tests for Your Controllers ==

In Rails, testing the various actions of a single controller is called writing functional tests for that controller. Controllers handle the incoming web requests to your application and eventually respond with a rendered view. 

=== What to include in your Functional Tests ===

You should test for things such as:

 * was the web request successful?
 * was the user redirected to the right page?
 * was the user successfully authenticated?
 * was the correct object stored in the response template?
 * was the appropriate message displayed to the user in the view

Now that we have used Rails scaffold generator for our +Post+ resource, it has already created the controller code and functional tests. You can take look at the file +posts_controller_test.rb+ in the +test/functional+ directory.

Let me take you through one such test, +test_should_get_index+ from the file +posts_controller_test.rb+.

[source,ruby]
--------------------------------------------------
def test_should_get_index
  get :index
  assert_response :success
  assert_not_nil assigns(:posts)
end
--------------------------------------------------

In the +test_should_get_index+ test, Rails simulates a request on the action called index, making sure the request was successful and also ensuring that it assigns a valid +posts+ instance variable. 

The +get+ method kicks off the web request and populates the results into the response. It accepts 4 arguments:

* The action of the controller you are requesting. This can be in the form of a string or a symbol. 
* An optional hash of request parameters to pass into the action (eg. query string parameters or post variables).
* An optional hash of session variables to pass along with the request.
* An optional hash of flash values.

Example: Calling the +:show+ action, passing an +id+ of 12 as the +params+ and setting a +user_id+ of 5 in the session:

[source,ruby]
--------------------------------------------------
get(:show, {'id' => "12"}, {'user_id' => 5})
--------------------------------------------------

Another example: Calling the +:view+ action, passing an +id+ of 12 as the +params+, this time with no session, but with a flash message.

[source,ruby]
--------------------------------------------------
get(:view, {'id' => '12'}, nil, {'message' => 'booya!'})
--------------------------------------------------

NOTE: If you try running +test_should_create_post+ test from +posts_controller_test.rb+ it will fail on account of the newly added model level validation and rightly so.

Let us modify +test_should_create_post+ test in +posts_controller_test.rb+ so that all our test pass:

[source,ruby]
--------------------------------------------------
def test_should_create_post
  assert_difference('Post.count') do
    post :create, :post => { :title => 'Some title'}
  end

  assert_redirected_to post_path(assigns(:post))
end
--------------------------------------------------

Now you can try running all the tests and they should pass.

=== Available Request Types for Functional Tests ===

If you're familiar with the HTTP protocol, you'll know that +get+ is a type of request. There are 5 request types supported in Rails functional tests:

* +get+
* +post+
* +put+
* +head+
* +delete+

All of request types are methods that you can use, however, you'll probably end up using the first two more often than the others.

=== The 4 Hashes of the Apocalypse ===

After a request has been made by using one of the 5 methods (+get+, +post+, etc.) and processed, you will have 4 Hash objects ready for use:

* +assigns+ - Any objects that are stored as instance variables in actions for use in views.
* +cookies+ - Any cookies that are set.
* +flash+ - Any objects living in the flash.
* +session+ - Any object living in session variables.

As is the case with normal Hash objects, you can access the values by referencing the keys by string. You can also reference them by symbol name, except for +assigns+. For example:

[source,ruby]
--------------------------------------------------
  flash["gordon"]               flash[:gordon]
  session["shmession"]          session[:shmession]
  cookies["are_good_for_u"]     cookies[:are_good_for_u]

# Because you can't use assigns[:something] for historical reasons:
  assigns["something"]          assigns(:something)
--------------------------------------------------

=== Instance Variables Available ===

You also have access to three instance variables in your functional tests:

* +@controller+ - The controller processing the request
* +@request+ - The request
* +@response+ - The response

=== A Fuller Functional Test Example

Here's another example that uses +flash+, +assert_redirected_to+, and +assert_difference+:

[source,ruby]
--------------------------------------------------
def test_should_create_post
  assert_difference('Post.count') do
    post :create, :post => { :title => 'Hi', :body => 'This is my first post.'}
  end
  assert_redirected_to post_path(assigns(:post))
  assert_equal 'Post was successfully created.', flash[:notice]
end
--------------------------------------------------

=== Testing Views ===

Testing the response to your request by asserting the presence of key HTML elements and their content is a useful way to test the views of your application. The +assert_select+ assertion allows you to do this by using a simple yet powerful syntax.

NOTE: You may find references to +assert_tag+ in other documentation, but this is now deprecated in favor of +assert_select+.

There are two forms of +assert_select+:

+assert_select(selector, [equality], [message])`+ ensures that the equality condition is met on the selected elements through the selector. The selector may be a CSS selector expression (String), an expression with substitution values, or an +HTML::Selector+ object.

+assert_select(element, selector, [equality], [message])+ ensures that the equality condition is met on all the selected elements through the selector starting from the _element_ (instance of +HTML::Node+) and its descendants.

For example, you could verify the contents on the title element in your response with:

[source,ruby]
--------------------------------------------------
assert_select 'title', "Welcome to Rails Testing Guide"
--------------------------------------------------

You can also use nested +assert_select+ blocks. In this case the inner +assert_select+ will run the assertion on each element selected by the outer `assert_select` block:

[source,ruby]
--------------------------------------------------
assert_select 'ul.navigation' do
  assert_select 'li.menu_item'
end
--------------------------------------------------

The +assert_select+ assertion is quite powerful. For more advanced usage, refer to its link:http://api.rubyonrails.com/classes/ActionController/Assertions/SelectorAssertions.html#M000749[documentation].

==== Additional View-based Assertions ====

There are more assertions that are primarily used in testing views:

[grid="all"]
`----------------------------------------------------------------------------------`-------------------------------------------------------
Assertion                                                                          Purpose
------------------------------------------------------------------------------------------------------------------------------------------
+assert_select_email+                                                              Allows you to make assertions on the body of an e-mail. 
+assert_select_rjs+                                                                Allows you to make assertions on RJS response. +assert_select_rjs+ has variants which allow you to narrow down on the updated element or even a particular operation on an element.
+assert_select_encoded+                                                            Allows you to make assertions on encoded HTML. It does this by un-encoding the contents of each element and then calling the block with all the un-encoded elements.
+css_select(selector)+  or +css_select(element, selector)+                         Returns an array of all the elements selected by the _selector_. In the second variant it first matches the base _element_ and tries to match the _selector_ expression on any of its children. If there are no matches both variants return an empty array.
------------------------------------------------------------------------------------------------------------------------------------------

Here's an example of using +assert_select_email+:

[source,ruby]
--------------------------------------------------
assert_select_email do
  assert_select 'small', 'Please click the "Unsubscribe" link if you want to opt-out.'
end
--------------------------------------------------

== Integration Testing ==

Integration tests are used to test the interaction among any number of controllers. They are generally used to test important work flows within your application. 

Unlike Unit and Functional tests, integration tests have to be explicitly created under the 'test/integration' folder within your application. Rails provides a generator to create an integration test skeleton for you. 

[source, shell]
--------------------------------------------------
$ script/generate integration_test user_flows 
      exists  test/integration/
      create  test/integration/user_flows_test.rb
--------------------------------------------------

Here's what a freshly-generated integration test looks like:

[source,ruby]
--------------------------------------------------
require 'test_helper'

class UserFlowsTest < ActionController::IntegrationTest
  # fixtures :your, :models

  # Replace this with your real tests.
  def test_truth
    assert true
  end
end
--------------------------------------------------

Integration tests inherit from +ActionController::IntegrationTest+. This makes available some additional helpers to use in your integration tests. Also you need to explicitly include the fixtures to be made available to the test. 

=== Helpers Available for Integration tests ===

In addition to the standard testing helpers, there are some additional helpers available to integration tests:

[grid="all"]
`----------------------------------------------------------------------------------`-------------------------------------------------------
Helper                                                                             Purpose
------------------------------------------------------------------------------------------------------------------------------------------
+https?+                                                                           Returns +true+ if the session is mimicking a secure HTTPS request.
+https!+                                                                           Allows you to mimic a secure HTTPS request.
+host!+                                                                            Allows you to set the host name to use in the next request.
+redirect?+                                                                        Returns +true+ if the last request was a redirect.
+follow_redirect!+                                                                 Follows a single redirect response.
+request_via_redirect(http_method, path, [parameters], [headers])+                 Allows you to make an HTTP request and follow any subsequent redirects.
+post_via_redirect(path, [parameters], [headers])+                                 Allows you to make an HTTP POST request and follow any subsequent redirects.
+get_via_redirect(path, [parameters], [headers])+                                  Allows you to make an HTTP GET request and follow any subsequent redirects.
+put_via_redirect(path, [parameters], [headers])+                                  Allows you to make an HTTP PUT request and follow any subsequent redirects.
+delete_via_redirect(path, [parameters], [headers])+                               Allows you to make an HTTP DELETE request and follow any subsequent redirects.
+open_session+                                                                     Opens a new session instance.
------------------------------------------------------------------------------------------------------------------------------------------

=== Integration Testing Examples === 

A simple integration test that exercises multiple controllers:

[source,ruby]
--------------------------------------------------
require 'test_helper'

class UserFlowsTest < ActionController::IntegrationTest
  fixtures :users

  def test_login_and_browse_site
    # login via https
    https!
    get "/login"
    assert_response :success
    
    post_via_redirect "/login", :username => users(:avs).username, :password => users(:avs).password
    assert_equal '/welcome', path
    assert_equal 'Welcome avs!', flash[:notice]
    
    https!(false)
    get "/posts/all"
    assert_response :success
    assert assigns(:products)
  end
end
--------------------------------------------------

As you can see the integration test involves multiple controllers and exercises the entire stack from database to dispatcher. In addition you can have multiple session instances open simultaneously in a test and extend those instances with assertion methods to create a very powerful testing DSL (domain-specific language) just for your application.

Here's an example of multiple sessions and custom DSL in an integration test

[source,ruby]
--------------------------------------------------
require 'test_helper'

class UserFlowsTest < ActionController::IntegrationTest
  fixtures :users

  def test_login_and_browse_site
    
    # User avs logs in
    avs = login(:avs)
    # User guest logs in
    guest = login(:guest)
    
    # Both are now available in different sessions
    assert_equal 'Welcome avs!', avs.flash[:notice]
    assert_equal 'Welcome guest!', guest.flash[:notice]
    
    # User avs can browse site
    avs.browses_site
    # User guest can browse site aswell
    guest.browses_site
    
    # Continue with other assertions
  end
  
  private
  
    module CustomDsl
      def browses_site
        get "/products/all"
        assert_response :success
        assert assigns(:products)
      end
    end
    
    def login(user)
      open_session do |sess|
        sess.extend(CustomDsl)
        u = users(user)
        sess.https!
        sess.post "/login", :username => u.username, :password => u.password
        assert_equal '/welcome', path
        sess.https!(false)
      end
    end
end
--------------------------------------------------

== Rake Tasks for Running your Tests ==

You don't need to set up and run your tests by hand on a test-by-test basis. Rails comes with a number of rake tasks to help in testing. The table below lists all rake tasks that come along in the default Rakefile when you initiate a Rail project.

[grid="all"]
--------------------------------`----------------------------------------------------
Tasks                           Description
------------------------------------------------------------------------------------
+rake test+                     Runs all unit, functional and integration tests. You can also simply run +rake+ as the _test_ target is the default.
+rake test:units+               Runs all the unit tests from +test/unit+
+rake test:functionals+         Runs all the functional tests from +test/functional+
+rake test:integration+         Runs all the integration tests from +test/integration+
+rake test:recent+              Tests recent changes
+rake test:uncommitted+         Runs all the tests which are uncommitted. Only supports Subversion
+rake test:plugins+             Run all the plugin tests from +vendor/plugins/*/**/test+ (or specify with +PLUGIN=_name_+)
------------------------------------------------------------------------------------


== Brief Note About Test::Unit ==

Ruby ships with a boat load of libraries. One little gem of a library is +Test::Unit+, a framework for unit testing in Ruby. All the basic assertions discussed above are actually defined in +Test::Unit::Assertions+. The class +ActiveSupport::TestCase+ which we have been using in our unit and functional tests extends +Test::Unit::TestCase+ that it is how we can use all the basic assertions in our tests.

NOTE: For more information on +Test::Unit+, refer to link:http://ruby-doc.org/stdlib/libdoc/test/unit/rdoc/[test/unit Documentation]

== Setup and Teardown ==

If you would like to run a block of code before the start of each test and another block of code after the end of each test you have two special callbacks for your rescue. Let's take note of this by looking at an example for our functional test in +Posts+ controller:

[source,ruby]
--------------------------------------------------
require 'test_helper'

class PostsControllerTest < ActionController::TestCase

  # called before every single test
  def setup
    @post = posts(:one)
  end

  # called after every single test
  def teardown
    # as we are re-initializing @post before every test
    # setting it to nil here is not essential but I hope 
    # you understand how you can use the teardown method
    @post = nil
  end

  def test_should_show_post
    get :show, :id => @post.id
    assert_response :success
  end

  def test_should_destroy_post
    assert_difference('Post.count', -1) do
      delete :destroy, :id => @post.id
    end

    assert_redirected_to posts_path
  end
  
end
--------------------------------------------------

Above, the +setup+ method is called before each test and so +@post+ is available for each of the tests. Rails implements +setup+ and +teardown+ as ActiveSupport::Callbacks. Which essentially means you need not only use +setup+ and +teardown+ as methods in your tests. You could specify them by using:

 * a block
 * a method (like in the earlier example)
 * a method name as a symbol
 * a lambda
 
Let's see the earlier example by specifying +setup+ callback by specifying a method name as a symbol:

[source,ruby]
--------------------------------------------------
require '../test_helper'

class PostsControllerTest < ActionController::TestCase

  # called before every single test
  setup :initialize_post

  # called after every single test
  def teardown
    @post = nil
  end

  def test_should_show_post
    get :show, :id => @post.id
    assert_response :success
  end
  
  def test_should_update_post
    put :update, :id => @post.id, :post => { }
    assert_redirected_to post_path(assigns(:post))
  end

  def test_should_destroy_post
    assert_difference('Post.count', -1) do
      delete :destroy, :id => @post.id
    end

    assert_redirected_to posts_path
  end
  
  private 
  
  def initialize_post
    @post = posts(:one)
  end
  
end
--------------------------------------------------

== Testing Routes ==

Like everything else in you Rails application, it's recommended to test you routes. An example test for a route in the default +show+ action of +Posts+ controller above should look like:

[source,ruby]
--------------------------------------------------
def test_should_route_to_post
  assert_routing '/posts/1', { :controller => "posts", :action => "show", :id => "1" }
end
--------------------------------------------------

== Testing Your Mailers ==

Testing mailer classes requires some specific tools to do a thorough job.

=== Keeping the Postman in Check ===

Your +ActionMailer+ classes -- like every other part of your Rails application -- should be tested to ensure that it is working as expected.

The goals of testing your +ActionMailer+ classes are to ensure that:

* emails are being processed (created and sent)
* the email content is correct (subject, sender, body, etc)
* the right emails are being sent at the right times

==== From All Sides ====

There are two aspects of testing your mailer, the unit tests and the functional tests. In the unit tests, you run the mailer in isolation with tightly controlled inputs and compare the output to a knownvalue (a fixture -- yay! more fixtures!). In the functional tests you don't so much test the minute details produced by the mailer Instead we test that our controllers and models are using the mailer in the right way. You test to prove that the right email was sent at the right time.

=== Unit Testing ===

In order to test that your mailer is working as expected, you can use unit tests to compare the actual results of the mailer with pre-written examples of what should be produced.

==== Revenge of the Fixtures ====

For the purposes of unit testing a mailer, fixtures are used to provide an example of how the output _should_ look. Because these are example emails, and not Active Record data like the other fixtures, they are kept in their own subdirectory apart from the other fixtures. The name of the directory within +test/fixtures+ directly corresponds to the name of the mailer. So, for a mailer named +UserMailer+, the fixtures should reside in +test/fixtures/user_mailer+ directory.

When you generated your mailer, the generator creates stub fixtures for each of the mailers actions. If you didn't use the generator you'll have to make those files yourself. 

==== The Basic Test case ====

Here's a unit test to test a mailer named +UserMailer+ whose action +invite+ is used to send an invitation to a friend. It is an adapted version of the base test created by the generator for an +invite+ action.

[source, ruby]
-------------------------------------------------
require 'test_helper'

class UserMailerTest < ActionMailer::TestCase
  tests UserMailer
  def test_invite
    @expected.from    = 'me@example.com'
    @expected.to      = 'friend@example.com'
    @expected.subject = "You have been invited by #{@expected.from}"
    @expected.body    = read_fixture('invite')
    @expected.date    = Time.now

    assert_equal @expected.encoded, UserMailer.create_invite('me@example.com', 'friend@example.com', @expected.date).encoded
  end

end
-------------------------------------------------

In this test, +@expected+ is an instance of +TMail::Mail+ that you can use in your tests. It is defined in +ActionMailer::TestCase+. The test above uses +@expected+ to construct an email, which it then asserts with email created by the custom mailer. The +invite+ fixture is the body of the email and is used as the sample content to assert against. The helper +read_fixture+ is used to read in the content from this file.

Here's the content of the +invite+ fixture:

-------------------------------------------------
Hi friend@example.com,

You have been invited. 

Cheers!
-------------------------------------------------

This is the right time to understand a little more about writing tests for your mailers. The line +ActionMailer::Base.delivery_method = :test+ in +config/environments/test.rb+ sets the delivery method to test mode so that email will not actually be delivered (useful to avoid spamming your users while testing) but instead it will be appended to an array (+ActionMailer::Base.deliveries+).

However often in unit tests, mails will not actually be sent, simply constructed, as in the example above, where the precise content of the email is checked against what it should be.

=== Functional Testing ===

Functional testing for mailers involves more than just checking that the email body, recipients and so forth are correct. In functional mail tests you call the mail deliver methods and check that the appropriate emails have been appended to the delivery list. It is fairly safe to assume that the deliver methods themselves do their job You are probably more interested in is whether your own business logic is sending emails when you expect them to got out. For example, you can check that the invite friend operation is sending an email appropriately:

[source, ruby]
----------------------------------------------------------------
require 'test_helper'

class UserControllerTest < ActionController::TestCase
  def test_invite_friend
    assert_difference 'ActionMailer::Base.deliveries.size', +1 do
      post :invite_friend, :email => 'friend@example.com'
    end
    invite_email = ActionMailer::Base.deliveries.first
    
    assert_equal invite_email.subject, "You have been invited by me@example.com"
    assert_equal invite_email.to[0], 'friend@example.com'
    assert_match /Hi friend@example.com/, invite_email.body
  end
end
----------------------------------------------------------------

== Other Testing Approaches

The built-in +test/unit+ based testing is not the only way to test Rails applications. Rails developers have come up with a wide variety of other approaches and aids for testing, including:

* link:http://avdi.org/projects/nulldb/[NullDB], a way to speed up testing by avoiding database use.
* link:http://github.com/thoughtbot/factory_girl/tree/master[Factory Girl], as replacement for fixtures.
* link:http://www.thoughtbot.com/projects/shoulda[Shoulda], an extension to +test/unit+ with additional helpers, macros, and assertions.
* link: http://rspec.info/[RSpec], a behavior-driven development framework

== Changelog ==

http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/8[Lighthouse ticket]

* November 13, 2008: Revised based on feedback from Pratik Naik by link:../authors.html#asurve[Akshay Surve] (not yet approved for publication)
* October 14, 2008: Edit and formatting pass by link:../authors.html#mgunderloy[Mike Gunderloy] (not yet approved for publication)
* October 12, 2008: First draft by link:../authors.html#asurve[Akshay Surve] (not yet approved for publication)

